/*  gSAFE - LIB
    general Sql dAtabase FrontEnd
    http://hyperprog.com/gsafe/

   (C) 2005-2017 Peter Deak  (hyper80@gmail.com)

    License: GPLv2  http://www.gnu.org/licenses/gpl-2.0.html

    datalib.h
*/

#ifndef GSAFE__DATALIB_HEADER_FILE_X_
#define GSAFE__DATALIB_HEADER_FILE_X_

#include <QtCore>

/** \mainpage
 *  gSAFE is a General Sql dAtabase Front End multiplatform library written in C++ based on Qt (http://qt.nokia.com).
 *  It is a complex system which define meta objects (Tables / Lists), which can autogenerate the graphical interfaces to manipulate the data.
 *	These meta objects can work together with Sql databases (PostgreSQL,MySQL,Sqlite,Odbc) handles timestamps,
 *	concurence writing etc.
 *	The meta objects contains all information about the data which need to manupulete, shows, store,
 *	print or even make a excel table from its, including the attributes for the gui to edit the fields.
 *	You can define this meta object from program code or XML source. After you defined the meta object they can be
 *	attached to gui or send to printer or make a table. The gui is generated by the attributes of meta data table.
 *	This library enables you to develop sql based application really quick time.
 *	The base library is developed with Qt so the generated gui is a Qt based gui, work on all platform where the Qt runs.
 *	\n\n
 *	The base modules of gSAFE:
 *  \image  html pictures_doc/modules.png
 */

/** \defgroup datalib datalib */
/*  @{  */

#include "gstexts.h"

/** The version of gsafe */
#define GSAFE_VERSION   "1.3.20"

// ///////////////////////////////////
// BEGIN - CONFIG/MODIFIERS/MODULES //
// ///////////////////////////////////

#define PROGRESS_POSSIBILITY 1

#define MODULE_REFRESHAGENT_NETSERVER 1
#define REFRESHAGENT_TCPPORT          1234

#define MODULE_REFRESHAGENT_NETCLIENT 1

/** This multiplier is used in HSqlChoose. It is determine the over allocation of the hash table.
 *  If the multiplier is bigger, it will be less collision but will use more memory.
 *  Must be greater than 1.0.    */
#define HASHMUL 1.5

//#define VALIDATE_HALT_ON_FIRST_ERROR

// //////////////////////////////////
// END - CONFIG/MODIFIERS/MODULES  //
// //////////////////////////////////

#define MAX_SQL_INTERFACES  7

#define INNER_JOIN 0
#define LEFT_OUTER_JOIN 1

#define HEAD true
#define VALUE false

#ifdef MODULE_REFRESHAGENT_NETSERVER
#include <QtNetwork>
#endif
#ifdef MODULE_REFRESHAGENT_NETCLIENT
#include <QtNetwork>
#endif

// Global functions //

int getIndexOf(QStringList l,QString s);
void setErrorLocal(QString s);

/** Pops up an error message with QMessageBox.
 *  You can call this function everywhere in the program. (It blocks the execution)
 *  @param s the error string */
void error(QString s);

/** Converts a double value to char * string
 *  @param v the double value to convert
 *  @param buffer the buffer wehre the string is written
 *  @param bufflen the size of the buffer. (limits the max length of converted string)
 *  @param min specified the minimum displayed decimal digit fragments.
 *  @param max specified the maximum displayed decimal digit fragments.
 *  @param group the displayed digits will be groupped by three digit.
 *      (if group==1 means "2334455.34" displayed "2 334 455.45" )
 *  @return 1 if the buffer is smaller size than needed, 0 otherwise */
int my_dtoa(double v,char *buffer,int bufflen,int min,int max,int group);

/** Converts a double value to QString. It uses the my_dtoa function inside.
 *  @see my_dtoa */
QString doubleToQString(double val,int min,int max,int group);

#define ROUND_MATH  0
#define ROUND_FLOOR 1
/** Round a double value.
*   @param val the value to round
*   @param mode the round mode. Can be ROUND_MATH or ROUND_FLOOR */
double dRound(double val,int mode=ROUND_MATH);

/** Deepcopy a stringlist to another */
QStringList * deep_copy_stringlist(QStringList *target,QStringList *source);

// Classes //

class QTextCodec;
class QSqlDatabase;
class QSqlQuery;

QString convNationalToHtmlCodes(QString input);

/** XML data generator class.
 *  Write XML nodes, maintain the node stack, take care of coding etc...
 *  This class is help to write well formed (and good looking) xml data */
class HXmlWriter
{
    private:
        QString     codec_name;
        int         indent_pos;
        QTextStream *output_stream;
        QStack<QString> *node_stack;
        QTextCodec  *tc;
        bool no_recode;

    private:
        void eatData(QString d);

    public:
        /** Create a simple HXmlWriter class */
        HXmlWriter(void);
        /** Destructor */
        ~HXmlWriter(void);

        /** Returns that TextStrem-object which the XML data is written */
        QTextStream *getStream(void);
        /** Sets the TextStream-object which the XML data is written */
        void setStream(QTextStream *oo);

        /** Creates the XML header.
         *  @param enc encoding
         *  @param nullhead if nullhead is true the xml header is skipped. */
        void putHead(QString enc,bool nullhead = false);

        /** Creates an ordinary XML node. (On closing the node name is automatically written)
         *  @param n the name of the node
         *  @param parameters is a string which can optionally contain parameters
         *  @see endNode() */
        void beginNode(QString n,QString parameters="");

        /** Closes the current node.
         *  @see beginNode() */
        void endNode(void);

        /** Creates a node contains character data (Opens it, fill and close)
         *  @param n the name of the node
         *  @param data the character data
         *  @param parameters is a string which can optionally contain parameters    */
        void putCData(QString n,QString data,QString parameters="");

        /** Creates a node contains character data with truncation to max length(Opens it, fill and close)
         *  @param n the name of the node
         *  @param data the character data
         *  @param maxlength The data is truncated to this length */
        void putCDataLimited(QString n,QString data,int maxlength);

        /** Optionally creates a node contains character data wit truncation to max length
         *  Its only creates the node if data is not empty
         *  @param n the name of the node
         *  @param data the character data
         *  @param maxlength The data is truncated to this length */
        void putCDataOptLimited(QString n,QString data,int maxlength);

        /** Creates an empty node without content (This is not an open and a close node. It's a single node.)
         *  @param n the name of the node
         *  @param parameters is a string which can optionally contain parameters */
        void putEmptyNode(QString n,QString parameters="");

        /** Writes a string to the stream without any format or processing (It can contains xml data too)
         *  @param data is the content to write */
        void putRawData(QString data);

        /** Recodes the input string to QByteArray (with the defined encoding) The & sing is will untouched */
        QByteArray recodeDataNoconvert(QString d);

        /** Recodes the input string to QByteArray (with the defined encoding) The & sing is will be replaced to &amp; */
        QByteArray recodeData(QString d);
};

/** This is the "refresh agent" of gSAFE.
 *  This class is intend to refresh all sql table data which is updated in the sql database.
 *  You can use this class by creating an instance. (But only one instance in the program)\n
 *  If this class receive a notify with an sql table name it makes to refresh all HList in program which
 *  shows that table or depended table. \n
 *  You can extend the functionaity of this class not only one program but more instance of programs
 *  on whole network by using HRefreshAgentNetserver and HRefreshAgentNetclient.
 *  @see notify()
 *  @see HList */
class HRefreshAgent : public QObject
{
    Q_OBJECT

    protected:
        static HRefreshAgent *theone;

    public slots:
        int notifySlot(QString tblname);

    public:
        /** Creates the refresh agent (No need to store the pointer of the instance) */
        HRefreshAgent(void);
        ~HRefreshAgent(void);

        /** Call this function with an sql table name to makes refresh all HList which depend from that table.
         *  That's you need to do. Everything else is automatical.
         *  @param tblname the changed tablename    */
        static void notify(QString tblname);

        /** Returns the pointer of the refresh agent instance */
        static HRefreshAgent* getNotifyAgent(void) { return theone; }


    protected:
        void internalNotify(QString tblname);

    signals:
        /** This signals is used for notify the HList-s */
        void getnotify(QString tblname);
};

#ifdef MODULE_REFRESHAGENT_NETSERVER
/** The HRefreshAgentNetclient - The server class of HRefreshAgentNetclient
 *  This class is not connected to HRefreshAgent. If the machice running this server object,
 *  you have to run a client instance too to use HRefreshAgent on the network.
 *  That case the client has to be connected to localhost.
 *  @see HRefreshAgentNetclient */
class HRefreshAgentNetserver : public QObject
{
    Q_OBJECT

    public:
        /** Creates an instance of HRefreshAgentNetserver. Will be listening on network and allow connect from evrywhere */
        HRefreshAgentNetserver(void);
        /** Destructor */
        ~HRefreshAgentNetserver(void);

        /** Returns true if the server is running, otherwise false */
        static bool isRunning(void);
        /** Returns the pointer of the HRefreshAgentNetserver instance */
        static HRefreshAgentNetserver * getHRefreshAgentNetserver(void) { return theone; }
        /** Returns the server's ip address */
        static QString serverAddress();

    protected:
        static bool inNotify;
        static HRefreshAgentNetserver *theone;

    private:
        QTcpServer *tcpServer;
        QList<QTcpSocket *> tcps_list;
        QString laddr;

    private slots:
        int newConn(void);
        int request(void);
        int clientLeaving(void);
        int action(QString name,int sendernum);

};
#endif

#ifdef MODULE_REFRESHAGENT_NETCLIENT
/** This is the class which extends the functionality of HRefreshAgent to work on network and more program instance.
 *  It works as a network client which connect to the server.
 *  (The server runs an instance of HRefreshAgentNetserver) \n
 *  You can use this class by creating an instance afrer the HRefreshAgent.
 *  The HRefreshAgent instance must be created before creating HRefreshAgentNetclient instance!
 *  This class will be automatically find and work together with HRefreshAgent.
 *  You can set the HRefreshAgentNetserver IP address or name in the constructor. */
class HRefreshAgentNetclient : public QObject
{
    Q_OBJECT

    public:
        /** Creates an instance of HRefreshAgentNetclient and connect to the server_ip address */
        HRefreshAgentNetclient(QString server_ip);
        /** Destructor */
        ~HRefreshAgentNetclient();

        /** Returns true if the client is connected to server */
        static bool isConnected(void);
        /** Returns the pointer of the HRefreshAgentNetclient instance */
        static HRefreshAgentNetclient * getHRefreshAgentNetclient(void) { return theone; }

    protected:
        static bool inNotify;
        static HRefreshAgentNetclient *theone;

    private:
        QTcpSocket *socket;
        bool c_ok;

    private slots:
        int request(void);
        int serverClosing(void);
        int action(QString name);

    signals:
        /** Activated if the network connection is lost */
        void connectionLost();
        /** Activcated if the network connection is established */
        void connectionEstablished();
};
#endif

/** The base class of gSAFE */
class HBase : public QObject
{
    Q_OBJECT

    protected:
        /** Contains the name of class */
        QString whoami;
    public:
        /** Returns the type of the instance in a string (classname) */
        QString getWhoami(void);

    public:
        /** Constructor (Does no need to call directly)*/
        HBase(void);
        /** Destructor */
        ~HBase(void);
};

/** HPlainDataMatrix is a class store a table (X rows and Y columns). However it is usally contains sql tables
 *  this class is not an sql related class. It is usally used as a result of a complex sql query. ( submitNResultQuery() )
 *  With this class you can manipulate simple data tables, can make reports, printigs, xml tables or do anything with the data.
 *  @see HDispPlainDataMatrix
 *  @see HPlainDMD
 *  @see HXmloTable */
class HPlainDataMatrix : public HBase
{
    Q_OBJECT

    private:
        int col_count;
        QString title;
        QString exp_title;

        QString* hheader;

        QList<QVariant *> data;
        QList<QString>    control;
        QList<QVariant *>::iterator iter;
        QList<QString>::iterator iter_ctrl;
        bool *printCellWrap;
        int  *printMaxCellWidth;
        QString htmlcss;
    public:
        /** The default keyfield. Used when you put this object in HDispPlainDataMatrix.
         *  With keyfield you can specify the key of the HTableBrowser elements.
         *      This is important when the user clicks on an element. That case the "activateItem" signal will be emitted which
         *      tell the key of the activated item. This key value came from:
         *      -   If the keyfield = -2 (default) not specified. The HDispPlainDataMatrix tell the keyfield (in parameter).
         *      -   If the keyfield = -1 a new key will be generated, which will be the index number of the rows.
         *      -   If the keyfield >= 0 means the keyfield indexed column will be the index. */
        int keyfield;

    public:
        /** Returns the title of the table */
        QString getTitle(void) { return title; }
        /** Sets the title of the table */
        void setTitle(QString t) { title = t; }
        /** Sets the extended title of the table */
        void setExtendedTitle(QString xt) { exp_title = xt; }

        /** Created an empty table with a specified column number */
        HPlainDataMatrix(int col);
        /** Destructor */
        ~HPlainDataMatrix(void);

        /** Clears all cell data from HPlainDataMatrix. It keeps the header and title data. */
        void clearData();
        /** Clears all data from HPlainDataMatrix. It only keeps the column count data.
         *  Erase all cell data, header, and title data. */
        void clearAll();

        /** Returns the number of coumns */
        int columnCount();
        /** Returns the number of rows */
        int rowCount();
        /** Returns the number of records in the table. Same as rowCount() */
        int recordCount() { return rowCount(); }
        /** Returns the number of fields. Same as rowCount() */
        int fieldCount() { return columnCount(); }


        /** Sets a specified table header cell text*/
        void setHeaderCell(int col,QString strdata);

        /** Sets the whole table header text with a QString list */
        void setHeader(QList<QString> strlistdata);
        /** Sets the whole table header text with a list of QStrings */
        void setHeader(QString d1="",QString d2="",QString d3=""
                       ,QString d4="",QString d5="",QString d6=""
                       ,QString d7="",QString d8="",QString d9=""
                       ,QString d10="",QString d11="",QString d12=""
                       ,QString d13="",QString d14="",QString d15="");
        /** Returns the specified header text */
        QString getHeaderItem(int col);
        /** Returns the whole table header */
        QList<QString> getHeader(void);

        /** Sets wrap settings for the specified column which is needed for printing */
        void setColumnPrintWrap(int col,bool wrap) { if(col <= col_count) printCellWrap[col] = wrap; }
        /** Returns wrap settings for the specified column which is needed for printing */
        bool getColumnPrintWrap(int col)           { if(col <= col_count) return printCellWrap[col]; else return false; }
        /** Sets the maximum width of the specified column which is needed for printing */
        void setColumnPrintMaxWidth(int col,int m) { if(col <= col_count) printMaxCellWidth[col] = m; }
        /** Returns the maximum width of the specified column which is needed for printing */
        int  getColumnPrintMaxWidth(int col)       { if(col <= col_count) return printMaxCellWidth[col]; else return 0; }

        /** Do an ordinary find & replace process in the texts of cells but only in the specified column.
         *  If the parts parameter is false it is only replace in case of full cell matching. */
        void replaceTextInColumn(int col,QString find,QString replace,bool parts=false);
        /** Run down on the specified column row by row, and if found more cells with same text, it's only keep the first occurance.
         *  The other cells contains same text will be replaced an empty string */
        void replaceSameUnderCellToEmpty(int col);

        /** Sets the first row as current */
        void firstRow(void);
        /** Makes the next row as current */
        bool nextRow(void);
        /** Check if there is next row */
        bool isEnded(void);
        /** Removes the current row from the table */
        void removeCurrentRow(void);
        /** Returns the current row by returning a list of QVariants */
        QList<QVariant> currentRow(void);
        /** Returns the current row by returning a list of QStrings (All cells are converted to QString) */
        QList<QString> currentRowStr(void);
        /** Returns the current row by returning only one concatenated string with the specified separator
         *  (All cells are converted to QString) */
        QString currentRowStr(QString separator);
        /** Returns the control string of the current row (Control string is needed for making fancy report)
         *  @see getContentAsHtml() */
        QString currentRowControl(void);

        /** Adds a new row to the end of the table. */
        void addRow(QList<QVariant> listdata,QString ctrl="");
        /** Adds a new row to the end of the table. */
        void addRowStr(QList<QString> strlistdata,QString ctrl="");
        /** Adds a new row to the end of the table. */
        void addRowStr(QString d1="",QString d2="",QString d3=""
                      ,QString d4="",QString d5="",QString d6=""
                      ,QString d7="",QString d8="",QString d9=""
                      ,QString d10="",QString d11="",QString d12=""
                      ,QString d13="",QString d14="",QString d15="")
            {
                addRowStrCTRL("",d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15);
            }
        /** Adds a new row to the end of the table. */
        void addRowStrCTRL(QString ctrl,QString d1="",QString d2="",QString d3=""
                          ,QString d4="",QString d5="",QString d6=""
                          ,QString d7="",QString d8="",QString d9=""
                          ,QString d10="",QString d11="",QString d12=""
                          ,QString d13="",QString d14="",QString d15="");

        /** Appends an external HPlainDataMatrix to this table. */
        void appendHPainDataMatrix(HPlainDataMatrix *tail);

        /** Returns the specified row */
        QList<QVariant> getRow(int row);
        /** Returns the specified row */
        QList<QString> getRowStr(int row);
        /** Returns the specified row in one concatenated string with the specified separator
         *  (All cells are converted to QString) */
        QString getRowStr(int row,QString separator);

        /** Returns the content of the specified cell */
        QVariant getCell(int row,int col);
        /** Returns the content of the specified cell */
        QString getCellStr(int row,int col);
        /** Sets the content of the specified cell */
        void setCell(int row,int col,QVariant vdata);
        /** Sets the content of the specified cell */
        void setCellStr(int row,int col,QString strdata);

        /** Sets the control string of the specified row */
        void setRowControl(int row,QString ctrl);

        /** Appends and prepends the specified string to every cell of the specified column */
        void setAppendPrependColumn(int col,QString prepend,QString append);

        /** Removes every html tags <*> from the data cells if the control string contains : "optionalhtmltags".
         *  If the force_all is true it removes every even if the "optionalhtmltags" is missing. */
        void removeHTMLTags(bool force_all=false);

        /** Calculates the sum of the values of the specified column. (The cells have to be convertable to integer) */
        int sumCoulmnAsInt(int col);
        /** Calculates the sum of the values of the specified column. (The cells have to be convertable to float) */
        double sumCoulmnAsDouble(int col);
        /** Returns a string which contains the concatenated values of the specified column with the specified separator */
        QString concatenateCoulmn(int col,QString separator);

        /** It generates a html output from the object. Makes a report from the table.
         *  The params parameter can contains the combinations of the following flags/attributes/modifiers:
         *
         *   - "html" - Put the "html" toplevel node.
         *   - "css" - Put the htmlcss text as css part to the html. See setHtmlCssText()
         *   - "center" - Makes the whole content to center aligned.
         *   - "notitle" - Don't write the title of the data.
         *   - "width=X" - The width attribute of the html table header items
         *   - "border=X" - The border attribute of the html table
         *   - "pad=X" - The cellpadding attribute of the html table
         *   - "space=X" - The cellspacing attribute of the html table
         *   - "notable" - Don't create the "table" html node. (Useful to build only table parts)
         *   - "noheader" - Don't generate the header for the html table. (Useful to build only table parts)
         *   - "fullwidth" - The width attribute of the html table. (Not the header items)
         *
         *  The control string in rows can contains the combinations of flags/attributes/modifiers:
         *
         *   - "backgroundColor=RRGGBB" - Sets the bgcolor attribute of the "tr" node (One tr tag correspond to one row in data table)
         *   - "1cellexpandcenter" - "colspan" the first cell to the all table width.
         *   - "precell=XXX;" - Prepend the XXX text to every cell text.
         *   - "postcell=XXX;" - Append the XXX text to every cell text.
         *   - "expandCol=COLFROM-COLTO" - Colspan the COLFROM column to COLTO column. (You can use more then one)
         *   - "alignCellRight=COL" - Align the cell content to right in column COL ("td")
         *   - "alignCellCenter=COL" - Align the cell content to center in column COL ("td")
         *   - "addCellParam=COl:XXXX;" - Define any other attribute for the cell ("td") (For example: addCellParam=2:nowrap=\"nowrap\"; )
         *                                                              */
        QString getContentAsHtml(QString params);

        /** Set html css text. If you call getContentAsHtml()
         *  and you use the "css" in parameter this text is used as css definitions */
        void setHtmlCssText(QString css) { htmlcss = css; }

        /** Returns a string which contains the concatenated values of the specified column with the specified separator */
        QString getColumn(int col,QString separator);

    public slots:
        /** Emits the actionOnRecord signal with the given parametered key.
         *  Usally the gui call this slot to emit the signal. */
        int actLine(QString key);
        /** Emits the alternateActionOnRecord signal with the given parametered key.
         *  Usally the gui call this slot to emit the signal. */
        int alternateActLine(QString key);
    signals:
        /** This signal is emitted when the user (left) clicked on a record
         *  (Can be emitted directly by slot actLine() )  */
        void actionOnRecord(QString key);
        /** This signal is emitted when the user right clicked on a record
         *  (Can be emitted directly by slot alternateActLine() ) */
        void alternateActionOnRecord(QString key);

};

/** This class holds information about a single sql database system. Don't instance it directly.
 *  You have to redefine this class if you would like to write a new sql interface.
 *  @see HSqlInterface */
class HSqlSingleInterface
{
    public:
        HSqlSingleInterface();

    public:

        /** Contains the name of this mode */
        QString hsqli_currentModeName;

        /** If the SqlQuery->numRowsAffented function returns good value it is worth
         *  to set true, otherwise it is need to set false to makes the program works.   */
        bool hsqli_usequerysize;

        /** How the boolean type name looks like in sql */
        QString hsqli_booleantypename;

        /** How the true value looks like in the database? For example "1" or "TRUE" */
        QString hsqli_truevalue;

        /** How the false value looks like in the database? For example "0" or "FALSE"  */
        QString hsqli_falsevalue;

        /** The type of the HKey data field: true => VARCHAR false => INTEGER */
        bool hsqli_hkeytype_varchar_int;

        /** If the HKey field is varchar this value is determine the length of that varchar key field */
        int hsqli_varcharhkeylength;

        /** Does we need to create a sequence before the table to autoincrement primary key of the table. (True if yes) */
        bool hsqli_need_create_sequence_before;

        /** Sql creation string of a sequence. (The _SEQNAME_ is replaced to a sequence name) */
        QString hsqli_sequence_creation_string;

        /** In case of creating table (generate the CREATE TABLE string) the HKey data field will get this constraint
         *  (The _SEQNAME_ is replaced to a sequence name) */
        QString hsqli_hkeyconstraint;

        /** The size of VARCHAR typed charhash. Where this variable is the n in "VARCHAR(n)" */
        int  hsqli_charhash_varcharlength;

        /** The size of VARCHAR typed smalltext. Where this variable is the n in "VARCHAR(n)" */
        int  hsqli_smalltext_varcharlength;

        /** This attribute is true if we need to define the size of varchar types. Only affect largetext typed fields. */
        bool hsqli_largetext_sizemustdefine;

        /** The size of VARCHAR typed largetexth, if we need define. (See hsqli_largetext_sizemustdefine)
         *  Where this variable is the n in "VARCHAR(n)" */
        int  hsqli_largetext_varcharlength;

        /** Sql typename of the integer type (in case of CREATE TABLE) */
        QString hsqli_numbertypename;

        /** Sql typename of the float type (in case of CREATE TABLE) */
        QString hsqli_floattypename;

        /** Is there TIMESTAMP type or not? (If not it's impossible to insert this kind of field to tables) */
        bool hsqli_hastimestamptype;

        /** Sql typename of the timestamp field. (in case of CREATE TABLE) */
        QString hsqli_timestamptypename;

        /** Is there date type in the sql database (If not it is need to handle by varchar /like in sqlite/) */
        bool hsqli_hasdatetype;

        /** Sql typename of the date field (in case of CREATE TABLE)*/
        QString hsqli_datetypename;

        /** Has the SQLChoose field constraints or not? In case of CREATE TABLE */
        bool hsqli_sqlchooseconstraint;

        /** How can I get the current value for a timestamp field */
        QString hsqli_timestampnowvalue;

        /** Will the driver produced sql error messages be concatenated to the own generated error messages */
        bool hsqli_appendsqlerrormsg;

        /** How the string concatenation looks like in this interface. This attribute is conrols how the standard way
        *   concatenated strings passed to the sql database.
        *   - 0 means the standard sql way "alpha || ' and ' || beta"
        *   - 1 means the mysql way (the "alpha || ' and ' || beta" is converted to "CONCAT(alpha,' and ',beta)"
        *   - 2 means the mssql way (the "alpha || ' and ' || beta" is converted to "alpha+' and '+beta"
        *   */
        int hsqli_hackconvert_stdsqlconcatenation_to_local;
};

/** Interface for QSQLITE database on Win32 */
class HSqlSingleInterface_SqliteWin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_SqliteWin(void);
};

/** Interface for QSQLITE database on Linux */
class HSqlSingleInterface_SqliteLin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_SqliteLin(void);
};

/** Interface for PostgreSQL with QODBC database on Win32 */
class HSqlSingleInterface_PsqlOdbcWin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_PsqlOdbcWin(void);
};

/** Interface for PostgreSQL QPSQL database on Linux */
class HSqlSingleInterface_PostgresqlLin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_PostgresqlLin(void);
};

/** Interface for MySQL with QODBC database on Win32 */
class HSqlSingleInterface_MysqlOdbcWin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_MysqlOdbcWin(void);
};

/** Interface for MySQL with QMYSQL database on Linux */
class HSqlSingleInterface_MysqlLin : public HSqlSingleInterface
{
    public:
        HSqlSingleInterface_MysqlLin(void);
};

/** The base class of all sql related class. It contains important informations
 *  about the underlying sql database. For example: which format can be used for strings? or what types are in databases? etc...\n
 *  So in nutshell this is the sql format class.
 *  One single sql database type interface is hold in HSqlSingleInterface class.
 *  (You have to redefine that class to write a new interface)
 *  @see HSqlSingleInterface */
class HSqlInterface : public HBase
{
    Q_OBJECT

    private:
        static bool isset;
        static int currentDefaultInterface;
        static int defaultDefaultInterface;
        static HSqlSingleInterface *interfaces[MAX_SQL_INTERFACES];

        /** Signs the interface of this instance. This is an index of "interfaces" pointer array.
         *  This is the only non static member of HSqlInterface class.
         *  (Descendants only holds this data)  */
        int myinterface;

    public:
        /** Constuctor (Does no need to call directly) */
        HSqlInterface();
        /** Destructor */
        ~HSqlInterface();

        /** Sets the currewnt default sql configuration.
         *  This HSqlInterface instances/descendants keeps this sql interface settings permanently after creation.
         *  It means this function is SET A DEFAULT interface. So the objects (Even HTables,HList,etc) stays in that interface
         *  which was the current during the creation.\n\n
         *  Currrently possible modes:
         *      - "QtSqlite_Lin" Sqlite database under Linux (Qt internal sqlite)
         *      - "QtSqlite_Win" Sqlite database under Win32 (Qt internal sqlite)
         *      - "PostgreSQL_WinOdbc" Postgresql database with Odbc interface on windows
         *      - "PostgreSQL_LinPsql" Postgresql database on Linux with Qt interface
         *      - "MYSQL_WinOdbc" MYSQL database on Windows with Odbc interface
         *      - "MYSQL_LinQt" MYSQL database on Linux with Qt interface */
        static void setSqlMode(QString modename);

        /** If you set more then one setSqlMode() this function will load
         *  the first given interface to current default.
         *  @see setSqlMode() */
        static void setSqlModeBackToFirst(void);

        /** Copy the SQL interface settings from the given parameter HSqlInterface.
         *  (The HSqlHaldler's cloneSqlSettingsFrom() function will call this automatically!)  */
        void cloneSqlInterfaceSettingsFrom(HSqlInterface *other) { myinterface = other->myinterface; }

        /** Returns the interface describe object of the current instance, according to the myinstance attribute
         *  Use this class to get Sql interface informations!
         *  @see myinterface    */
        HSqlSingleInterface *myInterface(void) { return interfaces[myinterface]; }

        /** Returns the current HSqlSingleInterface interface pointer */
        static HSqlSingleInterface *currentDefaultSqlInterface(void);
        /** Returns the given named HSqlSingleInterface interface pointer */
        static HSqlSingleInterface *getSqlInterface(QString interfacename);

        /** Convert concatenated fields from standard sql to local according to the current interface.
         * @see HSqlSingleInterface::hsqli_hackconvert_stdsqlconcatenation_to_local */
        QString sqlConcatenateToLocal(QString string);

        /** Concatenate fields according to the current interface.
         * @see HSqlSingleInterface::hsqli_hackconvert_stdsqlconcatenation_to_local */
        QString sqlConcatenateToLocal(QStringList fields);
};

/** The base SQL data handler class. All class working with sql is inherited from this.
 *  Here are the base sql functions, to make the base operations, error handling, make transactions etc...
 *  This class can be used directly for making atomic sql operations too. \n
 *  The higher level sql manipulator classes are inherited from here.
 \code
    ...
    HSqlHandler sql;
    if( sql.submit0ResultQuery("INSERT INTO table(id,name) VALUES(\'001\',\'Paul\')","Error occured") )
    {
        //error occured
        ...
    }
    ...
 \endcode
 */
class HSqlHandler : public HSqlInterface
{
    Q_OBJECT

    protected:
        bool query_error_occured;

    private:
        static bool globalnew_nodefault;
        static QString globalnew_current_database;

        bool    nodefault;
        QString current_database;

    public:
        /** Currently active transaction number */
        static int trans;

    public:
        /** Creates an HSqlHandler */
        HSqlHandler(void);
        /** Destructor */
        ~HSqlHandler(void);

        /** If the program has multiple database connections, you can specify the current global database
         *  for the new HSqlHandler instances.\n
         *  Those (created) HSqlHandler instances keeps the database settings permanently after creation.
         *  It means this function is SET A DEFAULT database. So the objects (Even HTables,HList,etc) stays in that database
         *  which was the current during the creation.
         *  \code
                ...
                //the program default database is A
                ...
                HList *inAdb = myfactory->genHList("TableinA"); //create a HList in db A
                HSqlHandler::setCustomSqlDatabase("b_database"); //change the current def database to B
                HList *inBdb = myfactory->genHList("TableinB"); //create a HList in db B
                HSqlHandler::setDefaultSqlDatabase(); //change the current def database back to A

                inAdb->readList(); //it reads a table from A database
                inBdb->readList(); //it reads a table from B database

            \endcode
         *  @param databaseName the database name is that name which is used when you create
         *         the connection
         *            Example: QSqlDatabase db = QSqlDatabase::addDatabase("QODBC","this_is_the_name");
         *  @param sqlinterfacename you can set different sql interface for this new database.
         *      Works same way than Sql databases. If you give empty string it means no change.  */
        static void setCustomSqlDatabase(QString databaseName,QString sqlinterfacename = "");
        /** Sets the current default database connection to active on this object.
         *  It restores the sqlinterface too.
         *  @see setCustomSqlDatabase() */
        static void setDefaultSqlDatabase(void);

        /** Returns the QSqlDatabase object which sould be use.
         *  This function is used by the descendants. It controls that they use the correct database
         *  (In case of the program has multiple database connections
         *  @see setCustomDatabase()
         *  @see setDefaultDatabase() */
        QSqlDatabase workDB(void);

        /** Allocate the new QSqlQuery in the workDB() database. You have to delete after using! */
        QSqlQuery *allocateQSqlQuery(void);

        /** Copy the SQL settings from the given parameter HSqlHandler.
         *  (It calls cloneSqlInterfaceSettingsFrom() function too.)
         *  Copies the custom database data and interface informations. */
        void cloneSqlSettingsFrom(HSqlHandler *other);

        /** Begins an SQL transaction. Have to call this before calling a commit() or a rollback()
         *  @see commit()
         *  @see rollback()
         *  @see transaction() */
        void transaction(void);

        /** Commits the current transaction
         *  @see commit()
         *  @see rollback()
         *  @see transaction() */
        void commit(void);

        /** Rollback the current transaction
         *  @see commit()
         *  @see rollback()
         *  @see transaction() */
        void rollback(void);

        /** Submit a simple SQL command which have no result (DDL/DML command)
         *  @param q The text of the SQL command
         *  @param err In case of error the emitted error signal will be contains this message
         *  @param tdisabled FALSE:It is submitted in a new separate transaction, TRUE:Don's start a new transaction
         *  @return TRUE:error occured, this case it is emits an error signal with the specified err - string , FALSE: no error occured */
        bool submit0ResultQuery(QString q,QString err,bool tdisabled=false);

        /** Submit a simple SQL command which returns one result (One row,one cell) For example: SELECT count(*) FROM mytable;
         *  @param q The text of the SQL command
         *  @param err In case of error the emitted error signal will be contains this message
         *  @param tdisabled FALSE:It is submitted in a new separate transaction, TRUE:Don's start a new transaction
         *  @return NULL:if error occured, this case it is emits an error signal with the specified err - string otherwise it returns the result cell */
        QVariant submit1ResultQuery(QString q,QString err,bool tdisabled=false);

        /** Submits an SQL command which have a table result (Table with N row)
         *  @param N the column count of the result table. (Needed for allocate the HPlainDataMatrix)
         *  @param q The text of the SQL command
         *  @param err In case of error the emitted error signal will be contains this message
         *  @param tdisabled FALSE:It is submitted in a new separate transaction, TRUE:Don's start a new transaction
         *  @see HPlainDataMatrix
         *  @return The result table in a HPlainDataMatrix instance */
        HPlainDataMatrix* submitNResultQuery(int N,QString q,QString err,bool tdisabled=false);

        /** Queryes if the last SQL query is successfully executed or any error occured
         *  @return TRUE:error occured, FALSE:no error occured */
        bool errorStatus(void) { return query_error_occured; }

    signals:
        /** If any error occured during the sql execution this signal is emitted. The "err" will be contains the error describe. */
        void errorSignal(QString err);
};

class HDataField;
/* NOT DOCUMENTED: This is a helper class which is makes list from the HDataField-s. Don't use directly!
 * It is used by the HTableBase class automatically. */
class HDataField_List : public HSqlHandler
{
    Q_OBJECT

    public:
        HDataField_List(void);
        ~HDataField_List(void);

        void addElement(HDataField *d);
        void clearElements(void);
        void connectElement(HDataField_List *c);
        void disconnectElement(void);

    public:
        HDataField *data;
        HDataField_List *next;
        HDataField_List *nextall;

};

class HDataChangeLogger;

/** Table/List base class. This class is a base class of the SQL Table class (HTable) and the SQL List (HList) class.
 *  It except the common features of lists and tables for example the handling of data fields.
 *  If you build a meta table by hand (not from XML with HFactory) you have to use functions of this class.
 *  This class achives some base SQL functions too. Usally you have not to use this class directly but in derived class.
 *  @see HTable
 *  @see HList */
class HTableBase : public HSqlHandler
{
        Q_OBJECT

    protected:

        QString     tabletitle;
        int         field;
        HDataField_List *table,*run; // < Head of the list
        QString     sqlTable;
        QStringList *depend;

        /** Needed for connected tables.
         *  This variable is contains the connection string in that table which is base table.
         *  (Not the other which connected to the base) */
        QString conn_part;

        /** Administration data in that table which connected to the base table.
         *  IMC is I'M Commected    */
        QString     imc_thiskey,imc_thatkey;
        HTableBase *imc_thattable;

        /** Hold the names of the connected tables. On destructive closing: when the main table is destoryed the connected
         *  tables can be destoryed too. This is used by the interface libs on destructive close for reason of deleting. */
        QStack<HTableBase *> *connectedTableBases;

    public:
        /** If this extrafeatures attribute is true the gui put a print preview and an Excel XML save button
         *  on the top of the List / Table. This buttons is showed the correspond dialog, and handles
         *  the whole function automatically.*/
        bool extrafeatures;

        /** If gui_showtabletitle attrebute is true the gui put the table title above the data part
         *  Default is false. */
        bool gui_showtabletitle;

        /** Hold the last error string in case of error */
        QString errstr;

        /** Constructor, it created an empty base table, without data fields and any structure.
         *  @param The SQL name of the table. This table name will be used in queryes, updates etc... */
        HTableBase(QString t);
        /** Destructor */
        ~HTableBase(void);

        /** Deepcopy constructor. It clones the parameter HTableBase to itself.
         *  It copies the full data structure and state and attributes of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy the whole connected table you have to copy the tables one by one, and connect them again.
         *  @param x the source table */
        HTableBase(HTableBase *t);

        /** Deepcopy function. It clones the parameter HTableBase to itself.
         *  It copies the full data structure and state and attributes of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy a whole connected table you have to copy the tables one by one, and connect them again.
         *  @param x the source table */
        void deepcopy_from_htablebase(HTableBase *x);

        /** Function to make automated table connection. It connects the HConnect field to the HKey.
         *  You have to call this function in base table, and pass the connected table as parameter.
         *  IT IS RECOMMEND TO USE THIS FUNCTION INSTEAD OF THE GENERAL connectTable().
         *  @param ct pointer of the connected table. (HTableBase *)
         *  @param type the type of connection (SQL Conn type: INNER JOIN,LEFT OUTER JOIN)
         *      Only the INNER_JOIN and the LEFT_OUTER_JOIN is implemented.
         *  @param connconstraint is the other connection constraint except the base constraint string
         *      (If X:=connconstraint then in sql "... inner join a on a.k = b.l AND X ...")
         *  @see connectTable()     */
        void connectTable(HTableBase *ct,int type=INNER_JOIN,QString connconstraint="");

        /** Function to make a general table connection.
         *  You have to call this function in base table, and pass the connected table as parameter.
         *  @param ct pointer of the connected table. (HTableBase *)
         *  @param thiskey connected field of this table (Base table) That table where this function is called. (this)
         *  @param thatkey connected field of the connected table. Table passed as parameter. (ct)
         *  @param type is the type of connection (SQL Conn type: INNER JOIN,LEFT OUTER JOIN)
         *      Only the INNER_JOIN and the LEFT_OUTER_JOIN is implemented.
         *  @param connconstraint is the other connection constraint except the base constraint string.
         *      (If X:=connconstraint then in sql "... inner join a on a.k = b.l AND X ...")         */
        void connectTable(HTableBase *ct,QString thiskey,QString thatkey,int type=INNER_JOIN,QString connconstraint="");

        /** Clears the existing table connections. Have to call both in the base class and in the connected class too.
         *  Destories every table connections in all directions. (Base/Connected)
         *  It does not delete the connected tables!
         *  @see clearAndFreeConnections()  */
        void clearConnections(void);

        /** Clears the existing table connections and delete the connected tables. It destories all connections of the table.
         *  Only have to call in the base table because it's delete the connected tables.
         *  @see clearAndFreeConnections()  */
        void clearAndFreeConnections(void);

        /** Clears the data fields of the table. (Deletes all HDataField pointer)
         *  After you call this, you will get an empty table.
         *  @see addField() */
        void freeTable(void);

        /** Adds a new data field (data column) to the table.
         *  You can use this function to define the meta sql table field by field.
         *  (OR/AND you can use the HFactory class to define the metatable from XML file.)
         *  One HDataField (descendant) is usally related to an sql column of a table.
         *  @param i the HDataField (descendant) to add.
         *  @see freeTable
         *  @see HFactory   */
        void addField(HDataField *i);

        /** Access all data field step by step: Beginning of the sequence. The position will be on the first field.
         *  @see nextField()
         *  @see nextFieldAll() */
        void firstField(void);

        /** Access all data field step by step: Step to the next field, and return the current.
         *  Without connected tables!
         *  @see firstField()
         *  @see nextFieldAll() */
        HDataField *nextField(void);

        /** Access all data field step by step: Step to the next field, and return the current.
         *  With the fields of the connected tables too.
         *  @see firstField()
         *  @see nextField()    */
        HDataField *nextFieldAll(void);

        /** Returns a data field according to the SQL name of the field. (HDataField pointer)
         *  It search the specific sql named data field and returns it.
         *  @param sqln the sql name of the requested field.
         *  @param all If this parameter true the function will search the field in the connected tables too.
         *          otherwise it's only search in this table.
         *  @param containerSqlTable It is only used if the all parameter is true!
         *      In that case you search the field in the connected tabless too
         *      the containerSqlTable string act as a filter for sql table name.
         *      The fieldBySqlName(A,true,B) only returns that fields which are in B named table.
         *      Use this parameter when the connected tables contain more same named fields.
         *  @return the requested data field if found, otherwise NULL       */
        HDataField *fieldBySqlName(QString sqln,bool all=false,QString containerSqlTable="");

        /** Returns a data field according to the index of the field in the table. (HDataField pointer)
         *  It counts out the specific data field and returns it.
         *  @param i the number of the requested data field.
         *  @param all If this parameter true the function will search the field in the connected tables too.
         *          otherwise it's only search in this table.
         *  @returns the requested data field if found, otherwise NULL */
        HDataField *fieldByIndex(int i,bool all=false);

        /** Returns a static data field by it's title. (HStatic * but returned as HDataField *)
         *  HStatic fields are static non sql fields so you can't reach them by sql name.
         *  You can find a static field by index or with this function. (According to title)
         *  It is only search HStatic typed data fields.
         *  @param title the title of the requested static field.
         *  @return the requested data field if found, otherwise NULL       */
        HDataField *staticFieldByTitle(QString title="");

        /** Returns the number of fields in the table.
         *  @param withconnect If true the function count the connected fields too. */
        int fieldCount(bool withconnect=false);

        /** Sets the editable attribute on all data fields. (Every field will be editable) */
        void setEditable(void);

        /** Sets the readonly attribute on all data fields. (Every field will be read only) */
        void setReadonly(void);

        /** Sets every data field to hide/invisible. (The gui/print/etc won't show the hidden data fields) */
        void setHide(void);

        /** Sets every data field to show/visible. (The gui/print/etc will show these data fields) */
        void setShow(void);

        /** It sets a specified color for all data fields in this table.
         *  (The gui shows the fields according their colors)
         *  @param r Red component 0-256
         *  @param g Green component 0-256
         *  @param b Blue component 0-256 */
        void setColor(int r,int g,int b);

        /** Sets all datafields in this table to "UNSET"
         *  The data fields hold the status of their data related to the sql database,
         *  and knows wheter they updated by gui or not. (From non sql side!)
         *  If the field got "SET" status = the record need to be store to the database otherwise the changes lost.
         *  If the field got "UNSET" status = unnecessary to store the data to the database */
        void setAllNOSet(void);
        /** Sets all datafields in this table to "SET"
         *  The data fields hold the status of their data related to the sql database,
         *  and knows wheter they updated by gui or not. (From non sql side!)
         *  If the field got "SET" status = the record need to be store to the database otherwise the changes lost.
         *  If the field got "UNSET" status = unnecessary to store the data to the database */
        void setAllYESSet(void);

        /** Sets every data field logged attibute's to false.
         *  It means that non of the data fields are logged by the HDataFieldLogger
         *  @see setLogging()
         *  @see setLoggingAllMarked()
         *  @see HDataChangeLogger */
        void resetLogging(void);
        /** Sets every data field logged attibute's to true.
         *  It means that every data fields are logged by the HDataFieldLogger
         *  @see resetLogging()
         *  @see setLoggingAllMarked()
         *  @see HDataChangeLogger */
        void setLogging(void);

        /** Returns wheter the table have a field marked to "SET"
         *  If any field in the table has "SET" the function returns true, otherwise false.
         *  @param all If all is true it examines the connected tables too.
         *  @see setAllYESSet()
         *  @see setAllNOSet()  */
        bool isChanged(bool all=false);

        /** Returns the title string of the table */
        QString  tableTitle(void)         { return tabletitle; }
        /** Sets the title string of the table */
        void     setTableTitle(QString s) { tabletitle = s;    }

        /** Returns the sql name of the table */
        QString sqlTableName(void);

        /** Returns the explain texts of the fields (Every HDataField has an explain string) */
        QStringList getExplainHeads(void)      { return getHeads(1); }

        /** Returns the title texts of the fields (Every HDataField has an title string) */
        QStringList getShortTitleHeads(void) { return getHeads(2); }

        /** Returns the short/long text describe of the data fields
         *  The long text is the explain text. The short text is the title text.
         *  @param what If what=1 the function returns the explain text.
         *              If what=2 the function returns the title text. */
        QStringList getHeads(int what);

        /** Generates a complete full detailed sql SELECT command.
         *  It queries the full table without the key field. (Every data field but the HKey)
         *  By default the connected tables are ignored.
         *  @param tail If tail:=X the place of X in the SELECT is "SELECT .. FROM .. WHERE TRUE X"
         *      Fox example the tail can be: "AND key=1"
         *  @param all If the all false the function will ignore the connected tables, otherwise it generate the
         *      select for the connected tables too. (With joins)
         *  @param keypart If the keypart is true the select will limit to the current key.
         *      (After the WHERE. For example ... WHERE id='001'... )
         *      Otherwise (keypart=false) the select is not limited to the current key.
         *  @return The sql select command without ";"  */
        QString sqlSelect(QString tail="",bool all=false,bool keypart=false);

        /** Works same as sqlSelect() but the select is not limited to the current key and the select works on connected tables too.
         *  (the keypart parameter sqlSelect will be true)  /sqlSelect(tail,true,false)/
         *  @see sqlSelect()    */
        QString sqlSelectAll(QString tail="") { return sqlSelect(tail,true,false); }

        /** Works same as sqlSelect() but the select is limited to the current key.
         *  (the keypart parameter sqlSelect will be true)  /sqlSelect(tail,all,true)/
         *  @see sqlSelect()    */
        QString sqlSelectWk(QString tail="",bool all=false) { return sqlSelect(tail,all,true); }

        /** Works same as sqlSelect() but the select is limited to the current key and works on connected tables too.
         *  (the keypart parameter sqlSelect will be true)  /sqlSelect(tail,true,true)/
         *  @see sqlSelect()    */
        QString sqlSelectWkAll(QString tail="") { return sqlSelect(tail,true,true); }

        /** Returns the header text of the i numbered data field(column). */
        QVariant operator[](int i);

        /** Call this function to makes the gui to refresh.
         *  So if you call this function the gui will be notified to re-read the data.
         *  This achived by the "dataUpdatedSignal" QT SIGNAL.
         *  (When the gui starts it connects their slots to this signal/"dataUpdatedSignal"/ ) */
        void dataUpdated(void);

        /** Do not call this function unless you exacly know what you want. It's called automatically!
         *  It class HDataField::sqlSynced() function on all data field. */
        void sqlSynced(HDataChangeLogger *dclog = NULL,bool forcechange=false,bool forcelog = false);
        /** Clears the valueInSql and sync_valueInSql attributes to the default.
         *  It calls HDataField::clearSqlSynced() function on all data fields */
        void clearSqlSynced(void);
        /** Returns true if ony of the data field's value is changed according to the sql database value.
         *  It calls HDataField::isReallyChanged()
         *  @see HDataField::isReallyChanged() */
        bool isReallyChanged(void);

        /** Starts the validation of the data fields accoring the regex pattern.
         *  Starts the high level HDataField and the lower level (type dependent) tests.
         *  Returns empty string if the validation success otherwise the occured errors.
         *  @param all If true it checks the fields of connected tables too,
         *      otherwise only the fields of the base table is validated. */
        QString validate(bool all=true);

        /** Generates the sql create (DDL) string of the meta table. (CREATE TABLE ...)
         *  @return The sql create command
         *  @param switches string can contain modifiers. Currently there is not implemented any modifier. */
        QString sqlCreateString(QString switches="");

        /** Sets every field's "SHOW" flag which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set. */
        void setShowAllMarked(QString mark);
        /** Sets every field's "HIDE" flag which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set. */
        void setHideAllMarked(QString mark);
        /** Sets every field's "EDITABLE" flag which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set. */
        void setEditableAllMarked(QString mark);
        /** Sets every field's "READONLY" flag which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set. */
        void setReadolnyAllMarked(QString mark);
        /** Returns the value to the default every field which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set. */
        void returnToDefaultAllMarked(QString mark);

        /** All field, which has the "mark" marker will be emits the enableControl() signal which means the
         *  setEnabled(true) Qt function on the gui value editor control.
         *  @see setGuiDisabledAllMarked()  */
        void setGuiEnabledAllMarked(QString mark);
        /** All field, which has the "mark" marker will be emits the disableControl() signal which means the
         *  setEnabled(false) Qt function on the gui value editor control. (Visible but not editable)
         *  @see setGuiDisabledAllMarked()  */
        void setGuiDisabledAllMarked(QString mark);
        /** All field, which has the "mark" marker will be the logged attribute to set
         *  @see HDataField::setLogging()
         *  @see setLogging()
         *  @see resetLogging()
         *  @see HDataChangeLogger */
        void setLoggingAllMarked(QString mark);

        /** Sets every field's color attribute which has a mark passed in parameters.
        *   Every data field can have zero or more marker. If the mark match with one of the marks of a field the flag will be set.
        *   @param r Red component 0-256
        *   @param g Green component 0-256
        *   @param b Blue component 0-256 */
        void setColorAllMarked(QString mark,int r,int g,int b);

        /** Calls removeToolButton() function on all HSqlChoose instance
         *  @see HSqlChoose */
        void removeSqlCooseButtons(void);

        /** Equivalent to calling the folloving functions:
         *  -   setShow();
         *  -   setEditable();
         *  -   setHideAllMarked("HIDE_MARKER_PARAMETER");
         *  -   setReadolnyAllMarked("RO_MARKER_PARAMETER");
         *  -   removeSqlCooseButtons();
         *
         *  @param hide_marker the text HIDE_MARKER_PARAMETER
         *  @param ro_marker the text RO_MARKER_PARAMETER */
        void blockReInitializeBase(QString hide_marker,QString ro_marker);

        /** Apply the parameter passed role on this table.
         *  @param the rolename to apply
         *  @see HDataFieldRole */
        void useRole(QString name);
        /** Delete the parameter passed role from every data field.
         *  @param the rolename to delete
         *  @see HDataField::delRole()
         *  @see HDataFieldRole */
        void delRole(QString name);
        /** Clears every role from everywhere in this table.
         *  @see HDataField::clearRoles()
         *  @see HDataFieldRole */
        void clearRoles(void);

    public slots:
        /** For internaly use.
         *  This slot is used by the data fileds. The fields can pass their error messages to this table with this slot.
         *  The addField() function connects this slot to the errorSignal of the data field. */
        int errorPassSlot(QString err);

        /** Adds a table name to the list of dependencies. This names is used by the HRefreshAgent.
         *  The HRefreshAgent can receive notifications from anywhere with a sql table name.
         *  This notifications is automatically makes refresh all tables/lists which needed.
         *  You can add more sql table name to this table as dependencies with this function.
         *  If the refresh agent receive a table name "SOMETHING" every table and list will be
         *  refresh which name match that received table name "SOMETHING" or have any dependent table name match with the notify "SOMETHING". \n
         *  For example if this table works on an sql view which named "CALCULATEDSALARY" so the sql name of this table is
         *  "CALCULATEDSALARY" you can add the "SALARY" table to this table as dependendy. So when the "SALARY" table is modified
         *  the table/list will refres the data
         *  @param n the dependent sql table    */
        void addDependTableName(QString n);

    signals:
        /** Activated anytime when any data is changed in the memory every way and every directions.
         *  This change can came from inside or outside. (From gui or api or sql)
         *  Can be used to refresh the calculated or depended fields */
        void dataChanged(void);

        /** It is activated when any data is changed in the memory, and the change is come from the data handlig class not the GUI!
         *  So this function can be used to tell the GUI to refresh/reload the data from the memory */
        void dataUpdatedSignal(void);

        /** Activated when the table is modified in the sql database.
         *  It is used to notify other program parts which use same or dependent table. */
        void dataModifiedSignal(void);

#ifdef PROGRESS_POSSIBILITY

        /** Activated when a time consuming work start. Can be used by the progressbar or work indicator. */
        void startWorking(void);
        /** Activated when a time consuming work run. Can be used by the progressbar or work indicator. */
        void doWorking(void);
        /** Activated when a time consuming work finished. Can be used by the progressbar or work indicator. */
        void endWorking(void);

#endif

};

/** The HTable class is handle/store an sql record.
 *  Holds a meta-record of the meta table with values.\n
 *  This is the base read-write sql related class which can be used to edit the sql data.\n
 *  However this class usally hold only a record, its name is "HTable" because the usual appearance:
 *  \image html pictures_doc/htable.png
 *  This record can be a whole sql table record or a subset of a sql record or can contain more field.
 *  (by join, calculated data,static data etc...) \n
 *  Here every field (of the HTableBase) can store a value. This is a record or a record of a joined table system.
 *  This record can be read/store/reload/edited with this class.\n\n
 *  Here is an sql table:
 \code
    CREATE TABLE excerc
        (
            id          VARCHAR PRIMARY KEY,
            excer       VARCHAR,
            finished    BOOLEAN DEFAULT FALSE,
            price       NUMERIC DEFAULT 0,
            deadline    DATE
        );
 \endcode
 *  And the correspond HTable: (You can see the XML format in HFactory calss description)
 \code
    HTable *table = new HTable("excerc");
    table->addField(new HKey("id","Identifier","Id",""));
    table->addField(new HLargeText("excer","Task to do","Task","")->asColored(200,100,100));
    table->addField(new HCheck("finished","Finished","Finished","",
                                "false","Yes, It is done!","No, it is unfinished."));
    table->addField(new HNumber("price","Cost","Cost","usd",""));
    table->addField(new HDate("deadline","Deadline","Deadline","NOW",false,false));
 \endcode
 *  The HTable is showed by HDispTable in gui, looks like this way:
 *  \image html pictures_doc/hdisptable.png
 *  @see HTableBase */
class HTable : public HTableBase
{
    Q_OBJECT

    protected:
        bool ro_mask;
        bool reread_key;
        QString insertedKey;

        HDataChangeLogger *dclog;

    public:
        /** Creates an empty table.
         *  The created table don't contain any data field and don't have any connections.
         *  @param t the sql name of the table. */
        HTable(QString t);
        /** Destructor */
        ~HTable(void);

        /** Deepcopy constructor. It clones the parameter HTable to itself.
         *  It copies the full data structure and state and attributes and values of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy a whole connected table you have to copy the tables one by one, and connect them again.
         *  @param t the source table */
        HTable(HTable *t);

        /** Deepcopy function. It clones the parameter HTable to itself.
         *  It copies the full data structure and state and attributes and values of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy a whole connected table you have to copy the tables one by one, and connect them again.
         *  @param x the source table */
        void deepcopy_from_htable(HTable *x);

        /** Generates the sql insert command of the record.
         *  (But does not execute the any SQL command, just create a string)
         *  The insert contains the current values of the record.
         *  The insert sets the values of the HConnect fields too.
         *  @param insertkey If the inserkey is true the insert command will contain the key field and the current key value.
         *      Otherwise the key field is not appear in the insert. (In that case you can use an auto key generation algorithm) */
        QString sqlInsert(bool insertkey=false);

        /** Generates the sql insert command of the connected record group.
         *  (But does not execute the any SQL command, just create a string)
         *  The insert contains the current values of the record.
         *  The function generates the insert command of all table. Calculate the dependencies, and calculate the connection keys.\n\n
         *  Example:\n
         *      INSERT INTO peoples(name,age) VALUES('frank',20); \n
         *      INSERT INTO telephonenum(peopleid,number) VALUES((SELECT id FROM peoples WHERE name='frank' AND age=20 ORDER BY timestamp DESC),'00-1-XXXX-YYYY-ZZZZ');\n
         */
        QString sqlInsertAll(void);

        /** Generates the sql update command of the table which refresh the values of the sql record.
         *  (But does not execute the any SQL command, just create a string)
         *  @param all if all is true the command will update the connected tables too.
         *  Otherwise only the record of the base table is updated. */
        QString sqlUpdate(bool all=false);
        /** Generates the sql update command of the table and the connected tables too.
         *  @see sqlUpdate */
        QString sqlUpdateAll(void) { return sqlUpdate(true); }

        /** Returns of the header string/value of the key field of the record.
         *  @param head_val If true the function returns the sql name of the key field
         *                  If false the functionr returns the value of the key field
         *  @param intable Act as a filter. If a table name is specified the key field is searched only that table which named in this parameter */
        QString getKey(bool head_val,QString intable="");

        /** Returns the (in memory) value of the specified field.
         *  @param i the index of the requested field. */
        QVariant operator[](int i);

        /** Sets the value of the specified field of the record
         *  @param sqln the sql name of the field which is about to set
         *  @param v the value to set
         *  @param sdisable if this true the dataUpdated signal is disabled, otherwise (default) is emitted. */
        void setSqlFieldValue(QString sqln,QVariant v,bool sdisable=false);

        /** Returns the value of the specified field of the record
         *  @param sqln the sql name of the field which is about to query
         *  @return the requested value */
        QVariant getSqlFieldValue(QString sqln);

        /** Returns the current status of the read only mask of the table.
         *  You can set a read only mask to the table which is tell the gui to show the whole table in read only mode.
         *  If the read only mask is enable the whole table will be read only irrespectively of the status of the
         *  read_only value of the fields. The independent read only value of the fields are untouched. \n
         *  So this read only mask!
         *  DOES NOT MODIFY THE READ ONLY STATUS OF THE FIELDS!
         *  Useful to show a read only view from a memory instance of an editable table.
         *  @see enableReadonlyMask
         *  @see disableReadonlyMask    */
        bool readonlyMask(void) { return ro_mask; }

        /** Equivalent calling the following functions:
         *  -   returnToDefault()
         *  -   blockReInitializeBase()
         *
         *  Which is equivalent to call:
         *  -   setShow()
         *  -   setEditable()
         *  -   setHideAllMarked("HIDE_MARKER_PARAMETER")
         *  -   setReadolnyAllMarked("RO_MARKER_PARAMETER")
         *  -   removeSqlCooseButtons();
         *
         *  @param hide_marker the text HIDE_MARKER_PARAMETER
         *  @param ro_marker the text RO_MARKER_PARAMETER
         *  @see returnToDefault
         *  @see blockReInitializeBase */
        void blockReInitialize(QString hide_marker,QString ro_marker);

        /** Adds a data change logger object to the HTable. It's enables the logging data changes to an sql table.
         *  It does not delete the given object
         *  @see HDataChangeLogger */
        void setDataChangeLogger(HDataChangeLogger *dcl) { dclog = dcl; }
        /** Clears the data change logger object to the HTable. It's disables the logging data changes to an sql table.
         *  It does not delete the given object
         *  @see HDataChangeLogger */
        void clearDataChangeLogger(void) { dclog = NULL; }

        /** Returns the number of records in this table
         *  (It's always 1 in HTable because the HTable only represent one record ) */
        int recordCount(void) { return 1; }

    public slots:
        /** Queries a record from the sql database. And the values are actualized in this table.
         *  After the query 1 rows result are expected, and the memory values are automatically updated.
         *  @param key if the key contains a key value that key values record will be queried, otherwise the current value of the
         *      key field will be used to limit the query to one record.
         *  @param all if the all parameter is true the connected tables are updated too.
         *  @param update if this parameter is true the dataUpdated signal is emitted
         *  @param tdisabled if this parameter false the update runs in a separate transaction so the function starts a transaction
         *      and to a commit after its, otherwise (true) the function doesn't call any transaction related things.    */
        int updateWithKey(QString key="",bool all=false,bool update = true,bool tdisabled=false);

        /** Do an updateWithKey which run on the connected tabled too.
         *  @see updateWithKey */
        int updateWithKeyAll(QString key="",bool update=true,bool tdisabled=false) { return updateWithKey(key,true,update,tdisabled); }

        /** Sets the value of the first HKey field. (Set the key field of the record)
         *  @param key the value to set */
        int setKey(QString key);

        /** Store the (in memory) record to the sql database according to the key value of the HKey field.
         *  @param all store the connected tables too
         *  @param tdisabled if this parameter false the save runs in a separate transaction so the function starts a transaction
         *      and to a commit after its, otherwise (true) the function doesn't call any transaction related things.
         *  @returns 0 if success, 1 if error occured
         *  @see saveRecordAll() */
        int saveRecord(bool all=false,bool tdisabled=false);

        /** Store the record to the sql database with the saveRecord function but always works on connected tables too.
         *  @see saveRecord() */
        int saveRecordAll(bool tdisabled=false) { return saveRecord(true,tdisabled); }

        /** Inserts the current (in memory) record to the sql database.
         *  Inserts the values of the HConnect fields too.
         *  @param insertkey if true the function will inserts the value of the HKey field too, otherwise (false) the key field is
         *      does not appear in the insert command. Useful if the key field is autogenerated.
         *  @param disable_tr if this parameter false the insert runs in a separate transaction so the function starts a transaction
         *      and to a commit after its, otherwise (true) the function doesn't call any transaction related things.
         *  @param resetafterinsert if this true (default) the HTable calls returnToDefault() after a successfully insert.
         *  @return 0 if success, 1 if error occured
         *  @see insertRecordAll() */
        int insertRecord(bool insertkey=false,bool disable_tr=false,bool resetafterinsert=true);

        /** Inserts the current (in memory) record to the sql database.
         *  This function inserts the connected tables too.
         *  The function drops the values of the HConnect fields because it's filled during the connections.
         *  @param disable_tr if this parameter false the insert runs in a separate transaction so the function starts a transaction
         *      and to a commit after its, otherwise (true) the function doesn't call any transaction related things.
         *  @return 0 if success, 1 if error occured
         *  @see insertRecord() */
        int insertRecordAll(bool disable_tr=false);

        /** Gets the value of the HKey field immediatly after the insert command.
         *  The method is queries the value of the HKey field. It queries the key value according to the value of timestamp.\n
         *  THE RECORD/TABLE HAVE TO CONTAINS A TIMESTAMP FIELD TO WORK THIS FUNCTION CORRECTLY. \n
         *  The timestamp field have to enabled the check/controll option.
         *  This function need to be run in one sql transaction with the insert.
         *  You have to run the rereadNextInsertedKey() before the insert. \n
         \code
            ...
            HTable *mytable=...
            QString key;
            ...
            mytable->transaction();
            mytable->rereadNextInsertedKey();
            if(mytable->insertRecord(false,true) == 0) //success
            {
                key = mytable->getInsertedKey();
                mytable->commit();
            }
            else //error
            {
                mytable->rollback();
                ...
            }
            ...
         \endcode
         *
         *  It only works with insertRecord() , the insertRecordAll() is unsupported! */
        QString getInsertedKey(void) { return insertedKey; }
        /** The inserted key value will be queryied after the insert
         *  @see getInsertedKey() */
        void rereadNextInsertedKey(void) { insertedKey=""; reread_key = true; }

        /** Sets the values to the data fields to the default.
         *  Useful to run after the insert (before inserting a new element)
         *  @param all if true the function works on connected tables too */
        int returnToDefault(bool all=true);

        /** Enables the read only mask of the table.
         *  You can set a read only mask to the table which is tell the gui to show the whole table in read only mode.
         *  If the read only mask is enable the whole table will be read only irrespectively of the status of the
         *  read_only value of the fields. The independent read only value of the fields are untouched. So this read only mask
         *  DOES NOT MODIFY THE READ ONLY STATUS OF THE FIELDS! \n
         *  Useful to show a read only view from a memory instance of an editable table.
         *  @see disableReadonlyMask
         *  @see readonlyMask   */
        int enableReadonlyMask(void)  { ro_mask = true;  return 0; }
        /** Disables the read only mask of the table.
         *  You can set a read only mask to the table which is tell the gui to show the whole table in read only mode.
         *  If the read only mask is enable the whole table will be read only irrespectively of the status of the
         *  read_only value of the fields. The independent read only value of the fields are untouched. So this read only mask
         *  DOES NOT MODIFY THE READ ONLY STATUS OF THE FIELDS! \n
         *  Useful to show a read only view from a memory instance of an editable table.
         *  @see enableReadonlyMask
         *  @see readonlyMask   */
        int disableReadonlyMask(void) { ro_mask = false; return 0; }

    protected:
        QString getKeyValueAfterInsert(void);

        QString specifyKey(QString tablename);
};


#define FLOATTABLES_STS_UNDEF       0
#define FLOATTABLES_STS_ALIVE       1
#define FLOATTABLES_STS_NEW         2
#define FLOATTABLES_STS_DELETED     3
#define FLOATTABLES_STS_CANCELLED   4

/** The HFloatTables handles an array of HTable (records). The HFloatTables enables you not to syncronize the
 *  data immediately with the database.
 *  \image html pictures_doc/hfloattables.png
 *  So in nutshell, you can read some records from the database and modify, delete and add records
 *  in the memory wihout touching the sql database. After you manupulate this records (Which are HTable instances)
 *  you can store this record array with a single function. The HFloatTables will handle every change correctly in the database.
 *  It will delete the erased reccords, run update on the modified records, and do the necessary inserts to add the new ones.
 *  Ideal for that cases when you manipulate a bigger data structure, and don't want to apply the partial modifications to the database.
 *  That case you can use one or more HFloatTables to do the canges, and when every change is finished you can store all in the database
 *  in one transaction.\n
 *  The members can have 5 different state:  \n
 *  - UNDEF      Created as new in the memory but we don't know if is stay or not (Not in SQL)
 *  - ALIVE      There is in the memory and the databaase too (in SQL)
 *  - NEW        There is in the memory but the DB doesn't contain it. (Not in DB)
 *  - DELETED    Deleted from the memory, so we need to delete from the db too (in SQL)
 *  - CANCELLED  Deleted from the memory and the db doesn't contain its (It was a new record but deleted)(Not in SQL)
 *
 *  You can use the HFloatTables as HList (Put in a HDispList) with the HFloatTablesAsHList class   */
class HFloatTables : public HSqlHandler
{
    protected:
        QString sqlTable;
        bool fiter;
        QList<HTable *>::iterator titer;
        QList<int>::iterator siter;

    public:
        /** The base record */
        HTable *baserecord;
        /** List, stores the status of the records */
        QList<int>       *sts;
        /** List, stores the records itself */
        QList<HTable *> *tbls;

    public:
        /** Constructor. Created an empty HFloatTables with a base HTable record which act as a template record.
         *  The HFloatTables will contain that kind of records which the constructor gets in parameter.
         *  The table names come from that template record too.
         *  (Each record will be cloned from that template record.)
         *  @param baserec the template/base record. When you delete the HFloatTables the baserecord will be deleted too! */
        HFloatTables(HTable *baserec);
        /** Destructor. Deletes the base record too. */
        ~HFloatTables(void);

        /** Returns the sql name of the table. (Comes from the base record) */
        QString sqlTableName(void) { return sqlTable; }

        /** Returns the element number of the HFloatTables. (Record number)
         *  It is only count the ALIVE and NEW status elements. Nor the deleted and undefined records. */
        int count(void);
        /** Returns the number of records in this HFloatTable. Same as count(). */
        int recordCount(void) { return count(); }
        /** Returns the element number of the HFloatTables in all state. (Record number)
         *  It is count the elements in all state, deleted and undefined too. */
        int countAllStat(void);

        /** Returns an ALIVE or a NEW element (HTable *) from the table by value of a field
         *  @param field the a sql name of the filed which the value search in
         *  @param key the value of the searched field
         *  @return returns that record which contains the searched field with the specified value */
        HTable *getTByField(QString field,QString key);
        /** Returns an ALIVE or a NEW element (HTable *) from the table by their key value
         *  @param key the value of the key field
         *  @return returns that record which contains the key with the specified value */
        HTable *getTByKey(QString key);
        /** Returns an ALIVE or a NEW element (HTable *) from the table by the index
         *  @param idx the index of the searched record
         *  @return the requested record */
        HTable *getTByNum(int idx);

        /** Sets the status of every ALIVE and NEW record to NEW.
         *  Useful to duplicate/or re-store a record in the database because it tell the system to
         *  INSERT every record to the database (not update or skip) */
        void allAliveToNew(void);
        /** Sets a specified field to a specified value in every record
         *  @param fname the name of the field to set
         *  @param value the value to set  */
        void setAllField(QString fname,QVariant value);

        /** Step through the elements of HFloatTables. You can step through all elements by calling the first() and touch all
         *  all elements by calling nextRecord() or nextKey() until it is return NULL or empty string.
         *  @see nextRecord()
         *  @see nextKey()  */
        void first(void);
        /** Step through the elements of HFloatTables. You can step through all elements by calling the first() and touch all
         *  all elements by calling nextRecord() or nextKey() until it is return NULL or empty string.
         *  @see first()
         *  @see nextKey()
         *  @returns the pointer of the current record (as HTable *) or NULL if we reach the end of the table. */
        HTable *nextRecord(void);
        /** Step through the elements of HFloatTables. You can step through all elements by calling the first() and touch all
         *  all elements by calling nextRecord() or nextKey() until it is return NULL or empty string.
         *  @see first()
         *  @see nextRecord()
         *  @returns the value of the current record's key or empty string if we reach the end of the table. */
        QString nextKey(void);

        /** Adding a new record to the HFloatTables. (This does not do any SQL work!)
         *  You can ask a new HFloatTable record with this function. After you received the pointer you can fill
         *  the values of that HTable (or pu to gui, etc...)
         *  Every HFloatTable records have to created this way! \n
         *  This function creates the record with NEW state. This mean that this record will be inserted to the database.
         *  @see createRecordAsUndef()
         *  @return the new record's pointer (Clone of baserecord)*/
        HTable *createRecord(void);
        /** Adding a new record to the HFloatTables. (This does not do any SQL work!)
         *  You can ask a new HFloatTable record with this function. After you received the pointer you can fill
         *  the values of that HTable (or show with gui, etc...)
         *  Every HFloatTable records have to created this way! \n
         *  This function creates the record with UNDEF state. This means that we don't know the future of this record.
         *  Later you can call markedRecordToNew() function to make this record to valid, or call removeUndef() to cancel this record.
         *  This method is useful when you insert a new value with gui. First you get an instance which is showed by gui.
         *  After the user fill the gui, we call markedRecordToNew() if the user accepts the gui, or removeUndef() if the user cancell the dialog.
         *  @see createRecord()
         *  @see markedRecordToNew()
         *  @see removeUndef()
         *  @return the new record's pointer (Clone of baserecord) */
        HTable *createRecordAsUndef(void);
        /** Marks the record as NEW. (Related adding a new record)
         *  @see createRecordAsUndef() */
        void markedRecordToNew(HTable *r);
        /** Removes all record which have UNDEF status. (Related adding a new record)
         *  @see createRecordAsUndef() */
        void removeUndef(void);

        /** Erase a record from the HFloatTable (This does not do any SQL work!)
         *  @param the pointer of the element to delete */
        int deleteRecord(HTable *d);
        /** Erase a record from the HFloatTable (This does not do any SQL work!)
         *  @param the index of the element to delete */
        int deleteRecord(int idx);

        /** Clears the HFloatTables's records. (This does not do any SQL work!) */
        int clearMem(void);

        /** Reads a list of records from the SQL database to this HFloatTables.
         *  The query is builded according to the baserecord.
         *  Every row which are returned by query will be appear in HFloatTables as a record marked ALIVE.
         *  @param tdisabled if this parameter false the save runs in a separate transaction so the function starts a transaction
         *      and to a commit after its, otherwise (true) the function doesn't call any transaction related things.
         *  @param filter part of the SQL query. Where filter is "F" \n
         *          SELECT a,b,c... FROM tablename WHERE TRUE F; \n
         *          For example F = " AND deadline > date(now()) "
         *  @see HFloatTables */
        int readDBTable(QString filter,bool tdisabled=false);

        /** Store the current records of the HFloatTable to the SQL database. Every record is handled according their state.
         *  @see HFloatTables */
        int saveDBTable(bool tdisabled=false);
};

/** The HList holds a complete sql table or a subset of a table in readonly mode.
 *  It contains more record, and you can browse this records, but you can't edit anything.
 *  \image html pictures_doc/hlist.png
 *  This is the base class to browse/search/show the list of elements to the user. \n
 *  The class have a cursor which points to a record. (The user can select a record with this cursor) The keys is usally the HKey fields.
 *  So in details the list is contains records which means that we have a key list and a value array list.
 *  The key is used to select a record. (For cursor selection, etc) The value array list is the values of the sql table itself.
 *  An value array means a sql record values, so the HList contains the list of these value arrays, this is the data to show on display.
 *  This class appear in gui as table view (HDispList class), and also can be send to printer or xml excel table. \n
 *  This list also can be a connected table. (see HTableBase)\n
 *  The HList is showed by HDispList in gui, looks like this way:
 *  \image html pictures_doc/htablebrowser.png
 *  @see HTableBase */
class HList : public HTableBase
{
    Q_OBJECT

    protected:

        QStringList          *keys;
        QList<QStringList *> *values;
        QString              active_key;

        QList<QStringList *>::iterator  query_valiter;
        QStringList::iterator           query_keyiter;

    public:
        /** The last filter parameter (Stored on the last readList calling) */
        QString last_filter;
        /** The last all parameter (Stored on the last readList calling) */
        bool    last_all;

    public:

        /** Constructor. Creates an empty list.
         *  @param t the sql name of the related sql table */
        HList(QString t);
        /** Destructor. */
        ~HList(void);

        /** Deepcopy constructor. It clones the parameter HList to itself.
         *  It copies the full data structure and state and attributes and values of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy a whole connected table you have to copy the tables one by one, and connect them again.
         *  @param x the source list */
        HList(HList *t);
        /** Deepcopy function. It clones the parameter HList to itself.
         *  It copies the full data structure and state and attributes and values of the parameter table.
         *  But connected tables is not copied neither the connection data. Only the base table is copied!
         *  If you would like to copy a whole connected table you have to copy the tables one by one, and connect them again.
         *  @param x the source list */
        void deepcopy_from_hlist(HList *x);

        /** Returns the values of the whole HList.
         *  @return returns a list of QStringList where one QStringList is contains the values of a record */
        virtual QList<QStringList *>*  getValues(void) { return values; }
        /** Returns the keys of the whole HList.
         *  @return returns a QStringList where one QString is contains the key value of a record */
        virtual QStringList*           getKeys(void)   { return keys;   }

        /** Returns the title string of a specified field (by index). */
        QString operator[](int i);

        /** Returns the number of record's showd in this HList. */
        int recordCount(void) { return keys->count(); }

        /** Return the key of the currently active record. (Other subsystems for example gui can set a record as active) */
        QString activeKey(void);
        /** Sets a record active by specify the key value */
        void setActiveKey(QString k);

        /** Returns the value of a specified field on the position of active record.
         *  @param sqln the name of the field to get. */
        virtual QString getSqlFieldValue(QString sqln);

        /** Holds a key value. Used by gui related classes. It is not as hard as the active key, this key
         *  is that key where the (visible) gui cursor is stand on. Sometimes this variable is hold more current information
         *  about the selection of the user becuse it always point a record. The user don't have to explicitly select
         *  one record to fill this variable, but need to explicitly click or activate a record to make active.
         *  Fox example when the user scrolls through a list, the soft_current_key will set every key value where the cursor was,
         *  but only that record will be the active record where the user activate a record by a click. */
        QString soft_current_key;

        /** Step through the records: Sets the query cursor to the first record. */
        void queryToFirst(void);
        /** Step through the records: Step to the next record
         *  @return true if success, or false if we reach the end of the list
         *  @see queryToFirst() */
        bool queryNextRecord(void);
        /** Step through the records: Step to the next record and returns the value of the key field.
         *  @return the key of the next current element, or empty string if we reach the end of the list
         *  @see queryToFirst() */
        QString queryNextKey(void);
        /** Step through the records: Step to the next record and returns the values of the records.
         *  @return the values of the next current element, or empty list if we reach the end of the list
         *  @see queryToFirst() */
        QStringList* queryNextValues(void);
        /** Step through the records: Returns the current key value.
         *  @see queryToFirst()
         *  @see queryNextRecord() */
        QString queryCurrKey(void);
        /** Step through the records: Returns the values of the current record.
         *  @see queryToFirst()
         *  @see queryNextRecord() */
        QStringList* queryCurrValues(void);

    public slots:
        /** Clears the whole HList (clears keys and data values )*/
        virtual int clearList(void);

        /** Emits the actionOnRecord signal with the active record ( returned by activeKey() ). */
        int actLine(void);
        /** Emits the alternateActionOnRecord signal with the active record ( returned by activeKey() ). */
        int alternateActLine(void);

        /** Reads the list from the sql database. Every record returned by the query is appear on the list.
         *  @param all if true the connected tables are readed too.
         *  @param filter part of the SQL query. Where filter is "F" \n
         *          SELECT a,b,c... FROM tablename WHERE TRUE F; \n
         *          For example F = " AND deadline > date(now()) " */
        virtual int readList(QString filter="",bool all=true);
        /** Reads the list from the sql database.
         *  Same as the readList() but all parameter is strictly same as the previous readList().
         *  Useful to re-read (update) the list from the database.
         *  This slot is activated when the refresh agent notify tha table to refresh!
         *  @see readList()
         *  @see HRefreshAgent */
        int reReadList(void) { return readList(last_filter,last_all); }

        /** This function is used by HRefreshAgent automatically. Don't need to touch it... */
        int captureNotify(QString tblname);

    signals:
        /** This signal is emitted when the user (left) clicked on a record (Can be emitted directly by slot actLine() ) */
        void actionOnRecord(QString key);
        /** This signal is emitted when the user right clicked on a record (Can be emitted directly by slot alternateActLine() ) */
        void alternateActionOnRecord(QString key);

};

/** The HFloatTablesAsHList class is fake a HFloatTables to act as a HList.
 *  With this class you can browse and see an unexisting (sql point of view) table. \n
 *  You can put a HFloatTables instance to the HFloatTablesAsHList, and after it you can use the class as a HList.
 *
 *  \warning (1) The keys are generated (key in HList). This generated keys are independent from the keys in sql.
 *      The reason of the generated keys is that it can be same records which does not appear in the database so they can't have any key value.
 *      This records are tipically the NEW and UNDEF and CANCELLED records. \n
 *      So keep in mind that the keys are generated! This mean for example: you can't find the value of the active_key in the HFloatTables!
 *      \n\n
 *  \warning (2) If there is any changes on the data tables (in HFloatTables) the changes are only actualized, when the
 *      refreshValuesKeys() function is called! The reason is the speeding up the system. If you modify anything on the
 *      HFloatTable it would trigger a new data copy cycle. Because this modification signals are triggered every time
 *      when the gui cells is modified, it would be trigger many unnecessary refresh cycle. \n
 *      So the values from the HFloatTables only copied to HFloatTablesAsHList when you call this refreshValuesKeys() function. \n
 *      That means for exmample: if the user edit a record of the HFloatTable it is recommend
 *      to call refreshValuesKeys() only when the user hit Ok to the edit dialog.   \n\n
 *      If you have a HSmallText typed field in the tempate list which sql name is "NON_SQL_LIST_SERIAL" that case
 *      the refreshValuesKeys() will fill that field values with an index number.       */
class HFloatTablesAsHList : public HList
{
    Q_OBJECT

    protected:
        HFloatTables *mem;

    public:
        /** Constructor. Creates a HFloatTablesAsHList which fakes a HFloatTable get in memt parameter as HList
         *  @param memt the HFloatTables class to fake as Hlist
         *  @param templ if we dont want to specify the data fields of the HList (which faked)
         *      we can put this templ parameter and the constructor clones the data fields from this parameter
         *  @param clone_struct_from_memt if this true (false by default!) and the templ is NULL the HList (which faked) will be
         *      clones the data fields from the baserecord of the HFloatTables. \n
         *      So if you would like to the HList view same as the base record of FloatTables you should call HFloatTablesAsHList(some_pointer,NULL,true); \n
         *      This means that by default the HFloatTablesAsHList will be created with undefined data fields!  (Have to fill with HTableBase functions) */
        HFloatTablesAsHList(HFloatTables *memt,HList *templ=NULL,bool clone_struct_from_memt=false);
        /** Destructor */
        ~HFloatTablesAsHList();

        /** Returns the active table/record.  */
        HTable *getActiveTable(void);

        /** Refresh the values and the keys from the base HFloatTables. See the class description from details.
         *  @param updSignal emits an updateSignal or not.
         *  @see HFloatTablesAsHList */
        void refreshValuesKeys(bool updSignal=false);

        /** Inherited function. See HList::getValues() */
        virtual QList<QStringList *>* getValues(void) { return values; }
        /** Inherited function. See HList::getValues() */
        virtual QStringList*          getKeys(void)   { return keys; }

    public slots:
        /** Inherited function(HList): Only clears the temporally lists and refresh the values.
        If you would like to delete the table data use the HFloatTables::clearMem() ! */
        virtual int clearList(void);
        /** Inherited function(HList): calls the HFloatTables::readDBTable() with the filter and calls refreshValuesKeys() after it.
         *  @param filter this parameter is passed to HFloatTables::readDBTable()
         *  @param all does't do anything. */
        virtual int readList(QString filter="",bool all=true);

    private:
        //don't use this (that's why it is private)
        virtual QString getSqlFieldValue(QString sqln);

};

// ///////////////////////////////////////////////////////////////////////////////
// / Classes of data fields (and related) ////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////

/** The HDataFieldRole is a attribute modifier object for HDataField. It's the base class of the role system.\n
 *  You can use this role system to achive that a single meta table acts different ways in different situations.
 *  For example you can show/hide different data fields in different situations.\n
 *  The HDataFieldRole object is represent a single "role".
 *  Every role has to have a name. Later you can activate a role with this name.
 *  This role name represent a "situation". You can add roles to every (or some) data fields of a HTableBase,
 *  and later you can "activate" this roles with HTableBase::useRole() function.
 *  It means that every HDataField can have more roles. (with different names)\n
 *  A role can set the following attributes:
 *  - Show/Hide attribute
 *  - Editable/Readonly attribute
 *  - Guienable/Guidisable attribute
 *  - Reset the value to default
 *  - Set a role specified default value
 *
 *  The HDataFieldRole contstructor can receive a rolename a mod string and a value string
 *  (You can use this string in HFactory's xml format the following way:
 *      <role name="rolename" mod="hide;setval;" val="0"/> )\n
 *  The modifier string can contains the combination of the following strings:\n
 *  - "show;" or "hide;"
 *  - "editable;" or "readonly;"
 *  - "guienabled" or "guidisabled"
 *  - "reset;" this case the value will be returned to the default
 *  - "setval;"  this case the val attribute will be set as default value!
 *
 *  A valid mod string looks like this way: "show;readonly;setval;"
 *  You can also set the mod string by hand or use the add... functions below the generate it.
 *  @see HDataField */
class HDataFieldRole
{
    public:
        /** The name of the role */
        QString name;
        /** The mod string */
        QString mod;
        /** The value to set (If the mod contains "setval") */
        QString val;

    public:
        /** Creates an empty role */
        HDataFieldRole(void);
        /** Creates a role */
        HDataFieldRole(QString name,QString mod="",QString val="");

        ~HDataFieldRole(void);

        /** Sets the show attribute in this role */
        void addShowMod(void);
        /** Sets the hide attribute in this role */
        void addHideMod(void);

        /** Sets the editable attribute in this role */
        void addEditableMod(void);
        /** Sets the readonly attribute in this role */
        void addReadonlyMod(void);

        /** Sets the guienabled attribute in this role */
        void addGuienabledMod(void);
        /** Sets the guidisabled attribute in this role */
        void addGuidisabledMod(void);

        /** Sets the role to reset the value to default */
        void addResetMod(void);
        /** Sets the role to set the value to the "val" */
        void addSetvalMod(void);


        /** Returns true if the role has the show attribute */
        bool hasShowMod(void);
        /** Returns true if the role has the hide attribute */
        bool hasHideMod(void);

        /** Returns true if the role has the editable attribute */
        bool hasEditableMod(void);
        /** Returns true if the role has the readonly attribute */
        bool hasReadonlyMod(void);

        /** Returns true if the role has the guienable attribute */
        bool hasGuienabledMod(void);
        /** Returns true if the role has the guidisable attribute */
        bool hasGuidisabledMod(void);

        /** Returns true if the role will reset the value to the default */
        bool hasResetMod(void);
        /** Returns true if the role will set it's own value */
        bool hasSetvalMod(void);

};

/** HDataField is the base SQL field class. Every data field inherited from this class.
 *  It means that the HTableBase (so the HTable and HList too) contains HTableField descendants as data fields.
 *  As the base data field class, you can specify many properties which are in all field.
 *  This common attributes:
 *  - sql - Sign if the field is sql related or not? (Appers in the database or not?)
 *  - editable - If the field is editable or read only?
 *  - show - If the field is appear on gui, printer, etc... or hided?
 *  - guienabled - If the field's gui editor is disabled or enabled?
 *  - set - If the field is modified since the database read?
 *  - sqlColumn - The name of the field in sql database (column name)
 *  - explain text - The long explanation text/long name of the field.
 *  - title text - The brief name/title of the field (Appears in tables as header)
 *  - tail text - This text is appended after the value ( for example: USD,Hour,Meter,etc... )
 *  - default value - The default value of the field.
            You can set the default value with an sql query if you set "DEFVAL_SQL(the_sql_query)" here.
 *  - validator string - Validator regex pattern
 *  - not valid values - List of not alloved values
 *  - function - function modifier (see setFunction() )
 *  - subselect - subselects modifier (see setSubselect() )
 *  - etc...
 *
 *  You can use a role system to set some attributes together to customize the tables to different environments.
 *  (See: HDataFieldRole)
 *
 *  Every new data type and field have to inherit from here, because the HTable,HList,HTableBase,etc classes use functions of this class
 *  to build the sql queries set the values, etc. If a data field require a different kind of sql handling, it has to redefine the
 *  functions of HDataField. */
class HDataField : public HSqlHandler
{
    Q_OBJECT

    protected:
        /** Sign if the field is modified, or not */
        int set;
        /** The long name/explain text of the field */
        QString explain;
        /** The brief name of the field (header in tables) */
        QString title;
        /** Text appended after the value ( for example: USD,Hour,Meter,etc... ) */
        QString tailstr;
        /** The name of the field in sql database (column name) */
        QString sqlColumn;
        /** The default value of the field */
        QString defval;
        /** A validator regex */
        QString valid;
        /** List of not allowed values. */
        QStringList notvalid;
        /** If the value of the field have to put in a function, for example: date(timestamp) */
        QString function;
        /** In case of query this part is called in brackets */
        QString derived;
        /** in HDispTable: If true the next datafield will be melded to one line with this. */
        bool    meldwithnext;
        /** in HDispTable: Don't put stretch expander between the QLabel (expain text) and the value editor widget */
        bool    nomiddlestretch;
        /** in HDispTable: specify the maximum width of the edit area */
        int     editboxmaxwidth;

        /** Special display sort */
        QString spec_disp_sort;

        bool lastvalidate_result;
        bool permanentvalidate_result;
        QString manual_validate_error;

        /** True if the field is editable */
        bool editable;
        /** True if the field is sql related */
        bool sql;
        /** True if the field is showed in the gui, printigs, etc */
        bool show;
        /** True if the data field's gui editor is enabled (default) */
        bool guienabled;

        int  wcellw_print;
        bool wcell_print;

        /** The color of the gui part */
        int color_r,color_g,color_b;

        /** Markers of the field (See HTableBase to understand markers) */
        QStringList markers;
        /** Contains the roles of the field */
        QList<HDataFieldRole> roles;

        /** If this field is true the changing of this value is logged (default:false)*/
        bool logged;
        /** This attribute is true if the valueInSql attribute contains valid value
         *  (valueInSql is set) */
        bool sync_valueInSql;
        /** Contains the value which stored in sql database. This value is not valid everytime.
         *  If the HDataField is just created the HDataField does not have any information about the sql value, so
         *  this field is not valid. This fact is represented with the sync_valueInSql attribute.
         *  IF this attribute (valueInSql) is valid it contains a getSQLValueAsString() */
        QString  valueInSql;

    public:
        /** If this table is connected to an another this attribute will be true automatically */
        bool connected;
        /** This field belong to the "conn_sqlTable" named sql table.
         *  By default this value is empty because the HTable contains this data,
         *  but if this field is a connected table this attribute will store the tablename. */
        QString conn_sqlTable;

    public:
        /** Constructor. Creates an HDataField instance. About the meaning of parameters see the class description.
         *  @param _sqlColumn sets the sqlColumn attribute
         *  @param _explain sets the explain text of the field
         *  @param tit sets the title text of the field
         *  @param _tailstr sets the tail text of the field
         *  @param _editable sets the editable attribute of the field   */
        HDataField(QString _sqlColumn,QString _explain,QString tit,
                   QString _tailstr="",bool _editable=true);
        /** Destructor */
        ~HDataField(void);

        /** Deepcopy constructor. It clones the parameter HDataField to itself.
         *  It copies the full data structure and state and attributes and values of the parameter field.
         *  @param t the source field */
        HDataField(HDataField *t);

        /** Sets some base data
         *  @param _sqlColumn sets the sqlColumn attribute
         *  @param _explain sets the explain text of the field
         *  @param tit sets the title text of the field
         *  @param _tailstr sets the tail text of the field
         *  @param _editable sets the editable attribute of the field   */
        void setData(QString _sqlColumn,QString _explain,QString tit,
                     QString _tailstr="",bool _editable=true);

    public:
        /** Deepcopy function. It clones the parameter HDataField to itself.
         *  It copies the full data structure and state and attributes and values of the parameter field.
         *  @param t the source field */
        void deepcopy_from_hdatafield(HDataField *x);

        /** Gives a clone of this HTableField (or descendants).
         *  @see deepcopy_from_hdatafield() */
        virtual HDataField* get_clone(void);

        /** Returns the explain text of the field (See HFloatTable class description)*/
        QString getExplainText(void) { return explain; }
        /** Returns the title text of the field (See HFloatTable class description) */
        QString getTitleText(void)   { return title;   }
        /** Returns the tail text of the field (See HFloatTable class description) */
        QString getTailText(void)    { return tailstr; }

        /** Sets the explain text of the field. It does not change/refresh the already builded gui components!
         *  (See HFloatTable class description)*/
        void setExplainText(QString expl);
        /** Sets the title text of the field.  It does not change/refresh the already builded gui components!
         *  (See HFloatTable class description) */
        void setTitleText(QString titl);
        /** Sets the tail text of the field.  It does not change/refresh the already builded gui components!
         *  (See HFloatTable class description) */
        void setTailText(QString tail);

        /** Sets a special sorting mode from this field. This sorting mode is only apply in gui lists
         *  Now only can receive one modifier: "dropchar" which means the characters are
         *  dropped from the value and the result converted to integer, then
         *  the result is sorted. \n
         *  (For example if the sorted values are: id_1,id_10,id_14,id_2,id_21  will be  1,2,10,14,21 */
        void setSpecDisplaySortMode(QString m) { spec_disp_sort=m;      }
        /** Gets the special sorting mode of the field
         *  @see setSpecDisplaySortMode()   */
        QString getSpecDisplaySortMode(void)      { return spec_disp_sort; }

        /** Sets the value of the field.
         *  @param sdisabled if this parameter is true the dataChanged() signal is disabled
         *  @return 0 if success.   */
        virtual int setValue (QVariant v,bool sdisabled=false);
        /** Returns the value of the field. */
        virtual QVariant getValue(void);
        /** Sets the default value of the field.
         *  @return 0 if success.   */
        virtual int setDefval(QVariant v);
        /** Returns the default value of the field in string format */
        QString getDefaultValue(void) { return defval; }
        /** Returns the value of the field in that format which accepted by the sql database. */
        virtual QString getSQLValue(void);
        /** Returns string format of the field's value.
         *  Very similar to getSQLValue() but the result is always acceptable in an sql varchar field.
         *  (Mostly used by the logger system, when every kind of values are stored in varchar.
         *  The gsafe try to keep the value as close to the original sql database value as possible) */
        virtual QString getSQLValueAsString(void);
        /** Returns the sql name of the field (in insert)
         *  This function can be redefined in descendats! */
        virtual QString sqlInsertHead(void);
        /** Returns the sql value of the field (in insert)
         *  This function can be redefined in descendats! */
        virtual QString sqlInsertValue(void);
        /** Returns the sql update part of the field ( name='VALUE' )
         *  This function can be redefined in descendats! */
        virtual QString sqlUpdate(void);
        /** Returns the sql name of the field (in select)
         *  This function can be redefined in descendats! */
        virtual QString sqlSelectHead(void);

        /** You can sing that the value is changed with this function. Calls resetValidateStatus()
         *  This function can be redefined in descendats!   */
        virtual void value_changed();

        /** Converting function, you can give a HDataFiled(or descendant) value to this function, and you get
         *  the corresponding sql value of the given value. \n
         *  This function usally redefined in descendats! \n
         *  In simple typed fields this function do a trivial conversion for example a text field do "text"->"'text'" conversion.
         *  Other cases where the field is more complex (HSqlChoose for example) this conversion can be more complex. \n\n
         *  In HSqlChoose can be: \n
         *  "Joe Black" -> "id_0123" \n
         *  "Little Richard" -> "id_03453" \n
         *  "John Wayne" -> "id_0197" \n
         *  etc... \n
         *  \n\n
         *  In a HCharHash the result can be: \n
         *  "Animal" -> "a" \n
         *  "Plant" -> "p" \n
         *  "Objects" -> "o" \n
         *  etc... \n
         *  \n  */
        virtual QVariant dbValueToDispValue(QVariant v);

        /** Returns the current value in sql format. Actually calls dbValueToDispValue() to the current value
         *  This function can be redefined in descendats!
         *  @see dbValueToDispValue() */
        virtual QVariant getDispValue() { return dbValueToDispValue(getValue()); }

        /** Returns true if the field is a sql database dependent field */
        bool isSQLField(void) { return sql; }
        /** Returns true if the field is editable, false if readonly.
         *  @see setEditable()
         *  @see setReadonly() */
        bool isEditable(void) { return editable; }
        /** Returns true if the field is appear in gui and other places, returns false if hided
         *  @see setShow()
         *  @see setHide() */
        bool isShow(void) { return show; }
        /** Returns true if the field value is modified, otherwise false *
         *  @see notSet()
         *  @see doSet() */
        bool isSet(void) { if(set) return true; else return false; }
        /** Returns true if the guiedabled attribute is true
         *  @see setGuienabled()
         *  @see setGuidisabled() */
        bool isGuienabled(void) { return guienabled; }

        /** Sets the field to editable (Removes readonly attribute)
         *  @see isEditable() */
        void setEditable(void);
        /** Sets the filed to readonly
          *  @see isEditable() */
        void setReadonly(void);
        /** Sets the field to show (removes the hide attribute)
         *  @see isShow() */
        void setShow(void) { show = true; }
        /** Sets the filed to hide (don't appar in gui,print list,xml etc...)
         *  @see isShow() */
        void setHide(void) { show = false; }
        /** Sets the guienabled attribute to true (Gui editor is enabled)
         *  @see isGuienabled() */
        void setGuienabled(void) { guienabled = true; }
        /** Sets the guienabled attribute to false (Gui editor is disabled)
         *  @see isGuienabled() */
        void setGuidisabled(void) { guienabled = false; }
        /** Sets the field's modified status to not modified!
         *  @see isSet() */
        void notSet(void) { set=0; }
        /** Sets the field's modified status to modified!
         *  @see isSet() */
        void doSet(void) { set=1; }
        /** Sets the field to log the data changes on sql database
         *  @see isLogged() */
        void setLogging(void) { logged = true; }
        /** Clears the field to log the changes on sql database
         *  @see isLogged() */
        void resetLogging(void) { logged = false; }
        /** Returns true if the field to log the changes on sql database
         *  @see setLogging()
         *  @see resetLogging() */
        bool isLogged(void) { return logged; }

        /** Sets the field to readonly, and return it */
        HDataField * asConstant(void) { setReadonly(); return this; }
        /** Sets the field to hide, and return it */
        HDataField * asHide(void) { setHide(); return this; }

        /** Sets the color of the field (appear in gui)
         *  @param r red component value 0-255
         *  @param g green component value 0-255
         *  @param b blue component value 0-255 */
        void setColor(int r,int g,int b);
        /** Returns the red component of the field's color */
        int getRColor(void) { return color_r; }
        /** Returns the green component of the field's color */
        int getGColor(void) { return color_g; }
        /** Returns the blue component of the field's color */
        int getBColor(void) { return color_b; }
        /** Sets the color of the field and return it
         *  @param r red component value 0-255
         *  @param g green component value 0-255
         *  @param b blue component value 0-255
         *  @see setColor() */
        HDataField * asColored(int r,int g,int b) { setColor(r,g,b); return this;}

        /** Sets the meldwithnext attribute to true.
         *  It is actualized in gui in HDispTable: If this attrubute is true this datafield
         *  will be melded to the next, so they will appear in one line. Useful if you would like to place more
         *  value editor in one line, which can be the three color components integer for example.
         *  Otherwise all field will be appear separated line.
         *  @see noMiddleStretch()
         *  @see resetMeldWithNext()
         *  @see isMeldedWithNext() */
        void meldWithNext(void)         { meldwithnext = true;  }
        /** Sets the meldwithnext attribute to false.
         *  @see meldWithNext() */
        void resetMeldWithNext(void)    { meldwithnext = false; }
        /** Returns true if the meldwithnext attribute is set.
         *  @see meldWithNext() */
        bool isMeldedWithNext(void)     { return meldwithnext;  }

        /** Sets the nomiddlestretch attribute to true.
         *  It is actualized in gui in HDispTable: The gui don't put stretch between the explain text and the value editor.
         *  Can be useful that cases when we have melded fields.
         *  @see meldWithNext()
         *  @see resetNoMiddleStretch()
         *  @see isNoMiddleStretch() */
        void noMiddleStretch(void)      { nomiddlestretch = true; }
        /** Sets the nomiddlestretch attribute to false.
         *  @see noMiddleStretch() */
        void resetNoMiddleStretch(void) { nomiddlestretch = false;}
        /** Returns true if the nomiddlestretch attribute is set.
         *  @see noMiddleStretch() */
        bool isNoMiddleStretch(void)    { return nomiddlestretch; }

        /** Sets the maximum width of the QLineEdit boxes when the field is edited in a HDispTable.
         *  If the value is 0 then the maximum is not specified.
         *  (This attribute only works on that kind of fields which are edited with QLineEdit) */
        void setEditBoxMaxWidth(int max) { editboxmaxwidth = max;  }
        /** Returns the maximum width of the QLineEdit boxes when the field is edited in a HDispTable.
         *  @see setEditBoxMaxWidth()   */
        int  editBoxMaxWidth(void) { return editboxmaxwidth; }

        /** If this functions returns true then the field accepts sql functions.
         *  Otherwise the setFunction() function is do nothing
         *  This function can be redefined in descendats!
         *  @see setFunction    */
        virtual bool acceptFunction(void) { return false; }
        /** Sets an sql function to this data field. When an sql query executed, the value of this field is queried with
         *  this function. Fox example you set "date" as function and this field is a "timestamp" named timestamp field then the
         *  sql select queries the value this way: date(timestamp)\n
         *  THIS ONLY WORKS IF THE FIELD IS READ ONLY. (Because it can be conflict if you would like to re-store this converted value)\n
         *  Currently the following typed fiels accept this function: HSmallText,HLargeText,HNumber,HFloating,HDate\n
         *  The accesibility of this function is signed by the acceptFunction() function. */
        void setFunction(QString func);
        /** Resets the function attrubute of the field
         *  @see setFunction()  */
        void resetFunction(void)       { function = "";   }
        /** Returns the currently actualized function of the field
         *  @see setFunction() */
        QString getFunction(void)      { return function; }

        /** If this functions returns true then the field accepts sql subselects instead of read a simple value.
         *  Otherwise setSubselect()  function is do nothing
         *  This function can be redefined in descendats!
         *  @see setSubselect   */
        virtual bool acceptSubselect(void) { return false; }
        /** Set a subselect to this field, instead read a simple sql value. When an sql query executed,
         *  the value is queried with the subselect which set here.\n
         *  For example "select date(now())"  -> SELECT field1,field2,(select date(now())),field4,... FROM ...\n
         *  THIS ONLY WORKS IF THE FIELD IS READ ONLY. (Because it can be conflict if you would like to re-store this queried value)\n
         *  Currently the following typed fiels accept this function: HSmallText,HLargeText,HNumber,HFloating,HDate \n
         *  The accesibility of this function is signed by the acceptSubselect() function. */
        void setSubselect(QString subs);
        /** Resets the subselect attribute of the field
         *  @see setSubselect() */
        void resetSubselect(void)       { derived = "";   }
        /** Returns the currently actualized subselect of the field
         *  @see setSubselect() */
        QString getSubselect(void)      { return derived; }

        /** Sets the width of the cell in print and print preview (0 means automatic, this is the default)*/
        void setPrintCellWidth (int w) { wcellw_print = w; }
        /** Returns the width of the cell in print and print preview (0 means automatic, this is the default)*/
        int  getPrintCellWidth (void)  { return wcellw_print; }

        /** Sets that the text of the cell can be wrapped in print and print preview */
        void setPrintCellWrap  (void)  { wcell_print = true; }
        /** Sets that the text of the cell cannot wrapped in print and print preview */
        void setPrintCellNoWrap(void)  { wcell_print = true; }
        /** Returns true if the text of the cell can be wrapped in print and print preview, otherwise false */
        bool isPrintCellWrap   (void)  { return wcell_print; }

        /** Returns the part of the CREATE TABLE sql command which creates this field */
        virtual QString sqlCreateStringPart(QString switches="");

        /** Sets the value of the data field to the default.  */
        int returnToDefault(void);

        /** Reads the given default value text and returns as a HDataField value.\n
         *  If you pass "DEFVAL_SQL(query_text)" string as default text, the "query_text" will be executed in sql database by this function,
         *  and the really defval will be the result.
         *  Usally you don't need to call this function. It's called by other functions automatically. */
        QVariant defvalParser(QString s);

        /** Do not call this function unless you exactly know, what you want!\n
         *  It sets the values of valueInSql and sync_valueInSql attributes.
         *  This function is automatically called whenewer it needs.
         *  It is signs, that the value is just syncrinized with the sql database.
         *  (Actually the HTable calls this function every time when the data is refreshed from the sql)
         *  It handles the logging too.
         *  @param dclog the Logger object. The function can palce the log messages into this object.
         *  @param forcechange the event is accepted as changing whenever the sync_valueInSql is false.
         *  @param forcelog the changing is logged whenever the logging attribute is false.
         *  @see clearSqlSynced()
         *  @see isReallyChanged() */
        void sqlSynced(HDataChangeLogger *dclog = NULL,bool forcechange=false,bool forcelog = false);
        /** Clears the valueInSql and sync_valueInSql attributes to the default.
         *  It meand that this field lose the information about the value in sql.
         *  Use this function if you detach the fild from the sql field.
         *  For example if you readed a HTable record and you want to save as another independent record.
         *  @see sqlSynced() */
        void clearSqlSynced(void);
        /** Returns true if the value is changed according to the sql database value.
         *  The normal isSet() function have already returns true that case the user changed
         *  the value to something else and set back to the original.
         *  But this function compares the readed sql value with the current, this means that this function always
         *  returns the effective changing status.        */
        bool isReallyChanged(void);

        /** Sets a regex to validate the field. If the modified value does not match with this regex, the gSAFE
         *  will drop an error signal and recejt the modifications. You can add more specific validations in the descendants too
         *  with the lowerValidate() function. \n
         *  The HDispTable will be sing the problematic element to the user. This works automatically. */
        void setValidator(QString v="");
        /** Validate the field.
         *  @see setValidator() */
        QString validate(void);
        /** Subtype (descendant) specific validation. (In HDataField this function does nothing)
         *  Descendants can be redefine this function to handle their validations.
         *  @return it returns an empty string if the value passed, otherwise the error string */
        virtual QString lowerValidate(void) { return QString(""); }

        /** Adds a disabled value (Can be added more than one disabled value)
         *  If the user modified a value which match with one of this disabled values the validation reject the modification. */
        void addNotValidValue(QString v);
        /** Sets more disabled value
         *  If the user modified a value which match with one of this disabled values the validation reject the modification. */
        void setNotValidValues(QStringList nvl);
        /** Clears all disabled value
         *  @see addNotValidValue() */
        void clearNotValidValues(void);

        /** Adds a new marker to the field. You can use this markes in higher levels (HTableBase,HTable,HList)
         *  You can create groups of fields with these markers, and later you can set some attribute or do something in batch on
         *  this group. Every field can have more markers, and later you can hide,show,coloring,set readonly, or do other things
         *  on fields which are marked with a specified marker. The markers are strings.
         *  @param mark marker to add.
         *  @see hasMark()
         *  @see clearMarkers()
         *  @see allMarker()    */
        void addMark(QString mark);
        /** Adds more then one marker to the field
         *  @see addMark() */
        void addMark(QStringList pmarkers);
        /** Returns true if the field have that marker given as parameter, otherwise false.
         *  @see addMark() */
        bool hasMark(QString mark);
        /** Clears all markers on this field.
         *  @see addMark() */
        void clearMarkers(void);
        /** Returns all markers of the field
         *  @see addMark()  */
        QStringList allMarker(void);

        /** Add a new role to this field. Every field can have more different named roles.
         *  @see HDataFieldRole */
        void addRole(HDataFieldRole role);
        /** Delete the parameter named role from this field.
         *  @see HDataFieldRole */
        void delRole(QString name);
        /** Clears every roles from this data field.
         *  @see HDataFieldRole */
        void clearRoles(void);
        /** Apply the parameter named role on this data field.
         *  If you pass rolename which does not appear here, it does nothing.
         *  A single role can set:
         *  - Show/Hide attribute
         *  - Editable/Readonly attribute
         *  - Guienable/Guidisable attribute
         *  - Reset the value to default
         *  - Set a role specified default value
         *
         *  @see HDataFieldRole */
        void useRole(QString name);

        /** Returns true if the last validation failed on this field.
         *  If the function returned true the field pass the validation.
         *  @see setValidator()
         *  @see lowerValidate()
         *  @see resetValidateStatus() */
        bool getLastValidateStatus() { return lastvalidate_result; }
        /** Clears the result of the last validation returned by getLastValidateStatus() .
         *  (Gui classes calls this function after queries the status)
         *  @see getLastValidateStatus() */
        void resetValidateStatus()   { lastvalidate_result=false;  }
        /** Returns true if the last validation failed on this field.
         *  If the function returned true the field pass the validation.
         *  YOU CAN'T RESET THE RESULT OF THIS FUNCTION with resetValidateStatus() !
         *  If a validation error make this function to return true, it will only return false again if the field
         *  gets a new value which pass the validation!
         *  @see setValidator()
         *  @see lowerValidate() */
        bool getPermanentValidateStatus() { return permanentvalidate_result; }
        /** You can set an external validate error manually with this function.
         *  Useful to handle checks according to the buisniss logics, or do other non sql or sintax check.
         *  If you set an error with this function, the gui subsystem will sing the error to the user.
         *  @param message the validate error mesage */
        void setMaulallyValidateError(QString message);

    public slots:
        /** Emits the disableControl signal. According to gui this usally makes the editable field to disabled in gui
         *  This means the setEnabled(bool) Qt QWidget function. (This means the element will be disabled)
         *  (Visible but not editable) */
        void disableControlSlot(void) { emit disableControl(); }
        /** Emits the enableControl signal. Enables the previously disabled field
         *  @see disableControlSlot() */
        void enableControlSlot(void) { emit enableControl(); }

    signals:

        /** Signs if the data changed. This passed to the HTableBase. */
        void dataChanged(void);

        void disableControl(void);
        void enableControl(void);

        /** Emitted when the object's static data changed. This can be the explain text, title text, tail text.
         *  The gui will refresh the changed static data. */
        void updateStaticDisplayElementsSignal(void);
};

/** This is a field type class. \n
 *  HKey holds a key data, which represent in the sql database.
 *  The value is readed from the database, but stays read only in gSAFE.
 *  Usally holds the primary key of the sql table.
 *  Many other function search this type to identify the records to read and write, \n
 *  SO IT IS STRONGLY RECOMMEND THAT EVERY SQL TABLE SHOULD CONTAIN A PRIMARY KEY (Which should be a HKey here)
 *  \n\n
 *  Gui appearance: The field have a simple readonly text label */
class HKey : public HDataField
{
    Q_OBJECT

    protected:
        QString value;

    public:
        /** Creates a HKey field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text
         *  @param tit the title text
         *  @param def the default value of the field */
        HKey(QString sqlc,QString ex,QString tit,QString def);
        /** Destructor */
        ~HKey(void);

        /** Deepcopy constructor */
        HKey(HKey *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HKey *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  HConnect is a connection field. Holds a string data which is a connection id to connect the table to another
 *  The value of the HConnect have a paired HKey value in the connected table.
 *  \n\n
 *  Gui appearance: The field don't have gui appearance */
class HConnect : public HDataField
{
    Q_OBJECT

    protected:
        QString connected_table;
        QString value;

    public:
        /** Creates a HConnect field
         *  @param sqlc the sql name of the field
         *  @param connected_tablep the name of the connected table */
        HConnect(QString sqlc,QString connected_tablep);
        /** Destructor */
        ~HConnect(void);

        /** Deepcopy constructor */
        HConnect(HConnect *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HConnect *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        /* Returns the name of the connected table */
        QString getConnectedTable(void) { return connected_table; }

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  HSmallText holds a text data, which is a simple varchar in the database.
 *  \n\n
 *  Gui appearance: Simple text edit field, only one line! (QLineEdit)    */
class HSmallText : public HDataField
{
    Q_OBJECT

    protected:
        QString value;
        bool initial_selected;

    public:
        /** Creates a HSmallText field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field */
        HSmallText(QString sqlc,QString ex,QString tit,QString t,QString def);
        /** Destructor */
        ~HSmallText(void);

        /** Deepcopy constructor */
        HSmallText(HSmallText *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HSmallText *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual bool acceptFunction(void) { return true; }
        virtual bool acceptSubselect(void) { return true; }

        virtual QString sqlCreateStringPart(QString switches="");

        /** Sets the edit widget to initially select the whole text, or not.
         *  @param selected true if selected, false if not.
         *  @see isInitialSelected() */
        void setInitialSelected(bool selected)  { initial_selected = selected;  }
        /** Retruns the initial selection status of the edit widget
         *  @see setInitialSelected() */
        bool isInitialSelected(void)            { return initial_selected;      }
};

/** This is a field type class. \n
 *  HLargeText holds a text data, which is a simple varchar in the database.
 *  \n\n
 *  Gui appearance: Multi lined text edit field, which more the one line high! (QMultiLineEdit)  */
class HLargeText : public HDataField
{
    Q_OBJECT

    protected:
        QString value;

    public:
        /** Creates a HLargeText field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param def the default text of the field */
        HLargeText(QString sqlc,QString ex,QString tit,QString def);
        /** Destructor */
        ~HLargeText(void);

        /** Deepcopy constructor */
        HLargeText(HLargeText *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HLargeText *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual bool acceptFunction(void) { return true; }
        virtual bool acceptSubselect(void) { return true; }

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  HCharHash holds one value of list of acceptable values. This represent as a small varchar in the sql database.
 *  You have to define key-value pairs of the selectable items. The user will see only the values in the gui, but the
 *  database will contain only the correspondig key value. \n
 *  For example the key - pair values can be:
 *  - "a" - "Animals"
 *  - "p" - "Plants"
 *  - "o" - "Objects"
 *  \n\n
 *  Gui appearance: Combobox, which shows the values, and you can select what you like. (QComboBox)  */
class HCharHash : public HDataField
{
    Q_OBJECT

    protected:
        QString value;

    public:
        /** The keys of the HCharHash */
        QStringList keys;
        /** The values of the HCharHash */
        QStringList values;

    public:
        /** Creates a HCharHash field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field
         *  @param k the keys of the charhash
         *  @param v the values of the charhash */
        HCharHash(QString sqlc,QString ex,QString tit,QString t,QString def,
                  QStringList k,QStringList v);
        /** Destructor */
        ~HCharHash();

        /** Deepcopy constructor */
        HCharHash(HCharHash *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HCharHash *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");

        /** Returns the correspond key of a given value. */
        QString getKeyOfValue(QString s);
        /** Returns the correspond value of a given value. */
        QString getValueOfKey(QString s);
};

/** This is a field type class. \n
 *  HNumHash holds one value of list of acceptable values. This represent as a numeric value in the sql database.
 *  You have to define key-value pairs of the selectable items. The user will see only the values in the gui, but the
 *  database will contain only the correspondig numeric key value. \n
 *  For example the key - pair values can be:
 *  - "1" - "Animals"
 *  - "2" - "Plants"
 *  - "3" - "Objects"
 *  \n\n
 *  Gui appearance: Combobox, which shows the values, and you can select what you like. (QComboBox)  */
class HNumHash : public HDataField
{
    Q_OBJECT

    protected:
        int value;

    public:
        /** The keys of the HNumHash. Have to be numeric values. (Can convert to int) "1" */
        QStringList keys;
        /** The values of the HNumHash */
        QStringList values;

    public:
        /** Creates a HNumHash field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field
         *  @param k the keys of the numhash Have to be numeric values. (Can convert to int) "1"
         *  @param v the values of the numhash     */
        HNumHash(QString sqlc,QString ex,QString tit,QString t,QString def,
                  QStringList k,QStringList v);
        /** Destructor */
        ~HNumHash();

        /** Deepcopy constructor */
        HNumHash(HNumHash *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HNumHash *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");

        /** Returns the correspond key of a given value. */
        QString getKeyOfValue(QString s);
        /** Returns the correspond value of a given value. */
        QString getValueOfKey(QString s);

};

/** This is a field type class. \n
 *  HNumber holds an integer value, which is a numeric value in the sql database too.
 *  \n\n
 *  Gui appearance: Numeric select box, one line high (QSpinBox)  */
class HNumber : public HDataField
{
    Q_OBJECT

    protected:
        int value;
        long int minimum,maximum;

    public:
        /** Creates a HNumber field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field */
        HNumber(QString sqlc,QString ex,QString tit,QString t,QString def);
        /** Destructor */
        ~HNumber(void);

        /** Deepcopy constructor */
        HNumber(HNumber *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HNumber *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual bool acceptFunction(void) { return true; }
        virtual bool acceptSubselect(void) { return true; }

        virtual QVariant dbValueToDispValue(QVariant v);

        virtual QString sqlCreateStringPart(QString switches="");

        virtual QString lowerValidate(void);

        /** Sets the minimum value of the field (check in validation) */
        void setMinimum(long int m) { minimum = m;    }
        /** Sets the maximum value of the field (check in validation) */
        void setMaximum(long int m) { maximum = m;    }
        /** Returns the minimum value of the field (check in validation) */
        long int getMinimum(void)   { return minimum; }
        /** Returns the maximum value of the field (check in validation) */
        long int getMaximum(void)   { return maximum; }

};

/** This is a field type class. \n
 *  HStatic is a static text label, which DOES NOT APPEAR IN DATABASE!
 *  This field is only used to separate the other fields to make "visual groups".
 *  \n\n
 *  Gui appearance: Simple text lablel. If you do not set default value the explain text is centered. (QLabel)
 *  If you set the default value the explain text will appear on left side, the default text right side. */
class HStatic : public HDataField
{
    Q_OBJECT

    protected:
        QString value;

    public:
        /** Creates a HStatic field.
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param def the default text of the field */
        HStatic(QString ex,QString tit="",QString def="");
        /** Destructor */
        ~HStatic(void);

        /** Deepcopy constructor */
        HStatic(HStatic *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HStatic *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  The HCheck holds a yes/no value, which is a boolean in the sql database.
 *  \n\n
 *  Gui appearance: Checkbox, which can be checked or not. (QCheckbox)
 *      You can specify a true and a false text which showed when the values is readonly or viewed or printed.\n
 *      Fox example you set true->"yes" false->"no" then the table shows: \n
 *      "Finished  ... yes" or "Finished ... no"    */
class HCheck : public HDataField
{
    Q_OBJECT

    protected:
        bool value;

    public:
        /** The "true" string */
        QString trues;
        /** The "false" string */
        QString falses;

    public:
        /** Creates a HCheck field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field
         *  @param ts the true string
         *  @param fs the false string */
        HCheck(QString sqlc,QString ex,QString tit,QString t,QString def,QString ts=GSAFETEXT_YES_HAVE,QString fs=GSAFETEXT_NO_HAVENOT);
        /** Destructor */
        ~HCheck(void);

        /** Deepcopy constructor */
        HCheck(HCheck *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HCheck *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  HFloating holds an floating point value, which is a floating point value in the sql database too.
 *  \n\n
 *  Gui appearance: Simple one lined text edit box (QLineEdit)  */
class HFloating : public HDataField
{
    Q_OBJECT

    protected:
        double value;
        double minimum,maximum;
        int dMminDf,dMmaxDf,dMgroup;

    public:
        /** Creates a HFloating field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param t the tail string of the field
         *  @param def the default text of the field */
        HFloating(QString sqlc,QString ex,QString tit,QString t,QString def);
        /** Destructor */
        ~HFloating(void);

        /** Deepcopy constructor */
        HFloating(HFloating *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HFloating *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual bool acceptFunction(void) { return true; }
        virtual bool acceptSubselect(void) { return true; }

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual QString sqlCreateStringPart(QString switches="");
        virtual QString lowerValidate(void);

        /** Sets the minimum value of the field (check in validation) */
        void setMinimum(double m) { minimum = m; }
        /** Sets the maximum value of the field (check in validation) */
        void setMaximum(double m) { maximum = m; }
        /** Returns the minimum value of the field (check in validation) */
        double getMinimum(void) { return minimum; }
        /** Returns the maximum value of the field (check in validation) */
        double getMaximum(void) { return maximum; }

        /** Sets the displaying method of the double value.
         *  Controls the return value of dbValueToDispValue()
         *  @param minDf specified the minimum displayed decimal digit fragments.
         *  @param maxDf specified the maximum displayed decimal digit fragments.
         *  @param groupDf the displayed digits will be groupped by three digit.
         *      (if groupDf=1 means "2334455.34" displayed "2 334 455.45" )      */
        void setDisplayMode(int minDf,int maxDf,int groupDf) {dMminDf=minDf; dMmaxDf=maxDf; dMgroup=groupDf; }

        /** Returns the current value as QString according to the values set with setDisplayMode()
         *  function. This function returns the value only
         *  (Does not append the tailtext. If you would like to append the tailtext too use the dbValueToDispValue() function) */
        QString getValueAsString(void);

};

/** This is a field type class. \n
 *  HDate holds a date value, which is a date type in the sql database too. (varchar in sqlite, but handled with functions)
 *  The HDate can hold a valid date or an unknown date. You can set the HDate to accept unknown date value or not.
 *  If you set the accesibility of unknown value with possible_unknown() the value can be unknow, (NULL in database).
 *  You can disable the accesibiliy of unknown value with impossible_unknown()\n
 *  The default value can be:
 *  - A valid date (as known)
 *  - "NOW" the currend date (as known)
 *  - "UNKNOWN" an unknown value (if you set to known the date will be 2000-01-01)
 *  - "UNKNOWN_AND_NOW" an unknown value (if you set to known the date will be current date)
 *
 *  \n\n
 *  Gui appearance: A date editor widget and a checkbox if the unknown value is accepted (QDateEdit & QCheck)*/
class HDate : public HDataField
{
    Q_OBJECT

    protected:
        /** The date value */
        QDate value;
        /** True if the unknown value is allowed */
        bool u_alive;
        /** True if the current value is unknown */
        bool unknown;

    public:
        /** Creates a HDate field.
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param def the default text of the field
         *  @param u_a the true if the Unknown value is Allowed
         *  @param unk true if the current value will be unknown */
        HDate(QString sqlc,QString ex,QString tit,QString def,bool u_a=true,bool unk=true);
        /** Destructor */
        ~HDate(void);

        /** Deepcopy constructor */
        HDate(HDate *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HDate *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        virtual bool acceptFunction(void) { return true; }
        virtual bool acceptSubselect(void) { return true; }

        /** Enables the possibility of unknown value */
        void possible_unknown(void)   { u_alive=true;   }
        /** Disables the possibility of unknown value */
        void impossible_unknown(void) { u_alive=false;  }
        /** Returns true if the unknown values are enabled */
        bool is_unknown_alive(void)   { return u_alive; }

        /** Sets the current value to unknown */
        void value_is_unknown(void);
        /** Sets the current value to known */
        void value_is_known(void);
        /** Returns true if the current value is unknown */
        bool is_value_unknown(void)   { return unknown; }

        /** Query the known value. Returns the known value even if the current is unknown too */
        virtual QVariant getKnownValue(void);

        virtual QString sqlCreateStringPart(QString switches="");
};

/** This is a field type class. \n
 *  HTimestamp holds a timestamp value, which is a timestamp in the database too.
 *  The timestamp field is readonly from user side. (from gui)\n
 *  It can be used in two mode. "controll" mode or "normal" mode.\n\n
 *  If you set the timestamp to control mode, it is refreshed everytime when the record is writed (updated or inserted)
 *  In "control" mode the timestamp prevents the concurent writing of the record. Every time when somebody updates the record the
 *  gSAFE compares the queried value with the value readed on the update.
 *  If the timestamps have different value the update is rejected.\n\n
 *  In normal mode the timestamp is only set on insert. Later you can't edit the value from gui, but with the api functions.
 *  This means that you can manipulate the value if you would like,
 *  but normally this kind of timestamp holds the create time of the record.
 *  \n\n
 *  Gui appearance: Readonly text label,in a single line (QLabel)  */
class HTimestamp : public HDataField
{
    Q_OBJECT

    protected:
        QString value;
        bool check;
        bool readed;

    public:
        /** Construnctor. Creates a HTimestamp
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param def the default text of the field
         *  @param c if true the HTimestamp will be in controll mode, otherwise it will be in normal mode. */
        HTimestamp(QString sqlc,QString ex,QString tit,QString def,bool c);
        /** Destructor */
        ~HTimestamp(void);

        /** Deepcopy constructor */
        HTimestamp(HTimestamp *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HTimestamp *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        /** Sets HTimestamp to control/check mode . */
        void set_havetocheck(void)      { check = true; }
        /** Sets HTimestamp to normal mode */
        void set_donthavetocheck(void)  { check = false; }
        /** Returns true if the HTimestamp is in control mode. */
        bool is_checkenabled(void)      { return check;  }

        void read_from_sql(void) { readed = true; }
        bool is_sqlreaded(void)  { return readed; }

        virtual QString sqlCreateStringPart(QString switches="");
};

/* NOT DOCUMENTED: Key - Value pair. Helper class of HSqlChoose. Don't use directly! */
class KVPair
{
    public:
        KVPair(void) { key = ""; value = ""; busy = false; }
        QString key,value;
        bool busy;
};

/** This is a field type class.
 *  The HSqlChoose holds a key value which is pointed a record in a different table.
 *  This field is a varchar in the database. You can browse the elements of the referenced table, and after you finish
 *  The field's value will contain the key of the selected record.\n
 *  You have to set many parameters to specify this connection (You can see examples in brackets)
 *
 *  - connected_table ( "persons" ) The sql name of the referenced table.
 *  - key_field ( "p_id" ) The key field which will be stored in this field as value.
 *  - showed_field ( "firstname || '|' || lastname  || '|' || birthdate" ) The showed fields of the referenced table.
 *      The user will see this content when select a value. The user won't see the key unless you put it again in showed_field.
 *      It can be more fields that case you have to concatenate the fields and put a "|" sign between its
 *      to tell the system this are separated fields.\n
 *      When you use HFactory to generate this object, you can use "showfieldeasy" instead "showfield".
 *      The showfield-> "alpha || '|' || beta" is equivalenet with showfieldeasy-> "alpha|beta".
 *  - showed_field_head ( "Firstname|Lastname|Birthdate" ) The header text of the showed fields. You have to also put "|"
 *      sign between the fields.
 *  - filter_part ( "age > 18") The filter part of the sql query.
 *      So you can limit the list of browseable items with this.
 *  - order_part ( "ORDER BY firstname,lastname,birthdate" )
 *      The initial sorting of the fields. Later the user can do his own sorting by clicking on the headers.
 *  - popupdialog_title ( "Select a person" ) If you set the selection to popup mode the popupdialog will showed with this title.
 *  - sortc ( 1 ) The default sorting of the element browser. (In popup mode only)
 *
 *  When the records of the referenced table are queried the select looks like this (according to example):\n\n
 *  SELECT p_id,firstname || '|' || lastname  || '|' || birthdate FROM persons
 *  WHERE age > 18 ORDER BY firstname,lastname,birthdate;    \n
 *  \n
 *  The HSqlChoose have two gui method to select the referenced record. This two modes can be set by easyform attribute:
 *
 *  -   If the easyform is true the user will see a combobox, and he can select the value by this combobox.
 *      The combobox will be filled with the values of showed_field.
 *
 *  -   If the easyform is false , the user will see a simple button with the selected record. If he hit the button, a new
 *      dialog window is popupped, with a complete browser list. The user can do sorting , letter to letter searching in this
 *      dialog. You can even placed a plus toolbutton which can be used to add a new non existing value, or do anything else.
 *
 *  The HSqlChoose uses a hash mechanism to store the keys. You can use three different hash function to speed up the
 *  browsing  "nullhash","charcodehash","dropchar" .
 *  \n\n
 *  Gui appearance: A combobox with a refresh button if easyform is true,
 *      otherwise a simple push button with a selected value. If you hit this pushbutton a new dialog is popupped with an element browser.
 *      (easyform-true: QComboBox easyform-false: HDialog,HTableBrowser)
 */
class HSqlChoose : public HDataField
{
    Q_OBJECT

    protected:
        /** Pointer to the hash function to speedup the key->value searching. */
        int (*hash)(const char*);

        QString value;

        QString connected_table;
        QString key_field;
        QString showed_field;

        QString showed_field_head;
        QString filter_part;
        QString order_part;
        QString popupdialog_title;
        int sortc; // gui based sort/sort by column c; c=-1(no sort)

        //If this attribute is false the referenced table is have not readed yet.
        // (It means the "keys" "values" "spevalues" has invalid status)
        bool readed_reftable;

        QStringList keys;      //cache
        QStringList values;    //cache
        QStringList sepvalues; //cache

        int maxhash;
        KVPair *pairs;

        /** Easyform attribute */
        bool easyform;

    public:
        /** The additional toolbar button event receiver
        *   see addToolButton*/
        const QObject *toolbrec;
        /** The additional toolbar button text
        *   see addToolButton*/
        QString btext;
        QString toolbarbutton_down_text;

        /** If this attribute is true the HSqlChoose show a graphical work indicator at time dependent sql reads */
        bool progress_on_read;

        /** Extrafunctions receivers
         *  see addExtraFunction() */
        const QObject* extrafunc_receiver[5];
        /** Extrafunctions texts
         *  see addExtraFunction() */
        QString extrafunc_text[5];

    public:
        /** Constructor. Creates a HSqlChoose
         *  @param sqlc the sql name of the field
         *  @param ex the explain text of the field
         *  @param tit the title text of the field
         *  @param def the default text of the field
         *  @param ct is the connected_table (See class details)
         *  @param kf is the key_field (See class details)
         *  @param sf is the showed_field (See class details)
         *  @param sfh is the showed_field_head (See class details)
         *  @param fp is the filter_part (See class details)
         *  @param op is the order_part (See class details)
         *  @param inthash is the internal hash function specifier: can be "nullhash","charcodehash","dropchar"
         *  @param easyform if this true (default) the HSqlChoose initialized in easyform. */
        HSqlChoose(QString sqlc,QString ex,QString tit,QString def,
                   QString ct,QString kf,QString sf,QString sfh,QString fp,QString op,
                   QString inthash="",bool easyf=true);
        /** Destructor */
        ~HSqlChoose(void);

        /** Deepcopy constructor */
        HSqlChoose(HSqlChoose *t);
        /** Deepcopy from the given parameter */
        void deepcopy_from(HSqlChoose *x);
        /** Returns a clone of this field */
        virtual HDataField* get_clone(void);

        virtual QVariant dbValueToDispValue(QVariant v);
        virtual int     setValue (QVariant v,bool sdisabled=false);
        virtual int     setDefval(QVariant v);
        virtual QVariant getValue(void);
        virtual QString getSQLValue(void);
        virtual QString getSQLValueAsString(void);
        virtual QString sqlInsertHead(void);
        virtual QString sqlInsertValue(void);
        virtual QString sqlUpdate(void);
        virtual QString sqlSelectHead(void);

        QString getConnectedTableName(void) { return connected_table; }

        /** Sets the filter part of HSqlChoose */
        void setFilterPart(QString fp);
        /** Sets the HSqlChoose to easyform=true (See class details) */
        void enableEasyForm(void);
        /** Sets the HSqlChoose to easyform=false (See class details) */
        void disableEasyForm(void);
        /** Returns true if the HSqlChoose in easyform, otherwise false (See class details) */
        bool getEasyForm(void) { return easyform; }

        /** Makes a refreshSqlValues() the next necessary time.
         *  It does not trigger an immedialty refreshSqlValues() but is emits when it needs same data) */
        void deferredSqlRefresh(void) { readed_reftable = false; }
        /** Makes the HSqlChoose to refresh the records of the referenced table.
         *  @param emitsignal is true the finction emits the dataUpdatedSignal() after the work.
         *  @param tdisabled FALSE:It is submitted in a new separate transaction, TRUE:Don's start a new transaction   */
        int refreshSqlValues(bool emitsignal=true,bool tdisabled=false);
        /** Returns the cached keys (readed keys of the records of the referenced table) */
        QStringList& getKeys  (void);
        /** Returns the cached values (readed keys of the records of the referenced table) */
        QStringList& getValues(void);
        /** Returns the separated values */
        QStringList& getSeparatedValues(void);
        /** Returns the header texts of showed fields (including "|" sings) */
        QString getFieldHeads(void) { return showed_field_head; }

        /** Sets the initial sort indicator in gui popup browser
         *  @param i the index of culumn to sort */
        void setGuiSortIndicator(int i) { sortc = i;    }
        /** Returns the current default column sort index in the popup selector. */
        int  getGuiSortIndicator(void)  { return sortc; }

        /** When the HSqlChoose is in normal mode (The selection achived with a popupped dialog)
         *  you can add a plus push button to that popupped dialog. You can specify a function (slot) which called when this
         *  button is pressed. \n
         *  When the user push this button the gSAFE activates the "toolbuttonclicked" slot of the "receiver" QObject.
         *  \n\n
         *  The gSAFE also try to connect to the "setKeyTo(QString)" signal of the "receiver".(optional)
         *  The called subprogram can set the current value by this signal. Useful if you use this plus button to add new
         *  element to the record list. After addig the record you can make immediately active with the setKeyTo signal.
         *  \n\n
         *  Have to call before the initialization of gui.
         *  @param receiver the receiver QObject descendant which have a toolbuttonclicked slot and an optional setKeyTo(QString) signal
         *  @param text the text of the button */
        void addToolButton(const QObject* receiver,QString text);
        /** Remove the plus toolbar button in normal mode.
         *  @see addToolButton() */
        void removeToolButton(void);

        /** When the HSqlChoose is in normal mode (The selection achived with a popupped dialog)
         *  you can add a plus position dependent popup menu(whith mouse right click), which can activated on the records of the referenced table.
         *  You can define more menu items (maximum 5). Every menu items have a receiver QObject which have to have a
         *  "extrafunc_X(QString key)" slot to handle the activating the menu. The X can be 0,1,2,3 or 4.\n\n
         *  For example if you call addExtraFunction(0,myobj,"Do something") that case if you click a right mouse button
         *  on an element of the referenced table a popupmenu will appear which will have a "Do something" menuitem.
         *  That case you click on this menu the "extrafunc_0(QString)" slot of myobj is activated, and the parameter will be the
         *  key value of the selected record.
         *  \n\n
         *  Have to call before the initialization of gui.
         *  @param pos the positon of the added menu. 0<= pos <5
         *  @param receiver the QObject descendant which have a "extrafunc_POS(QString) slot.
         *  @param text the text of the added menu item. */
        void addExtraFunction(int pos,const QObject* receiver,QString text);
        /** Removes all positon dependent popup menu in the popup selector
         *  @see addExtraFunction()*/
        void removeExtraFunction(void);

        /** Sets the title of the popupdialog when the HSqlChoose in normal mode */
        void setPopupDialogTitle(QString title) { popupdialog_title = title;    }
        /** Sets the title of the popupdialog to empty ("") when the HSqlChoose in normal mode */
        void resetPopupDialogTitle(void)        { popupdialog_title = "";       }
        /** Returns the title of the popupdialog  */
        QString getPopupDialogTitle(void)       { return popupdialog_title;     }

        /** Sets the key-value hash function manually */
        void setHashFunction(int (*nh)(const char*) ) { hash = nh; }
        /** Sets the key-value hash function by name */
        void setInernalHashFunction(QString hashname);

        virtual QString sqlCreateStringPart(QString switches="");

    signals:
        void dataUpdatedSignal(void);

    #ifdef PROGRESS_POSSIBILITY
        /** When using a work indicator: This signal is emitted when a work begins */
        void startWorking(void);
        /** When using a work indicator: This signal is emitted when a work continues */
        void doWorking(void);
        /** When using a work indicator: This signal is emitted when a work finished */
        void endWorking(void);
    #endif

};

//The default hash functions.
int nullhash    (const char *c); //Codename: "nullhash"
int charcodehash(const char *c); //Codename: "charcodehash"
int dropchar    (const char *c); //Codename: "dropchar"

// ///////////////////////////////////////////////////////////////////////////////
// / Classes of HDataChangeLoggerdata fields (and related) ///////////////////////
// ///////////////////////////////////////////////////////////////////////////////

/* NOT DOCUMENTED: Helper struct of HDataChangeLogger, do not use directly */
struct HOneDataChange
{
    QString pos;
    QString user;
    QString tablename;
    QString changedkey;
    QString fieldname;
    QString oldvalue;
    QString newvalue;
};

/** HDataChangeLogger is an object which can automatically log the data changes of a HTable into a separated sql table.
 *  Useful to store the history of a sql data table.\n
 *  Every data field in a table has an attribute "logged". If this "logged" attribute is true and the HTable
 *  has a valid HDataChangeLogger object set, every real data modifications is automatically logged to an sql table.\n
 *  (See HDataField::setLogging() and HDataField::resetLogging() to set the "logged" attribute. \n
 *   And see HTable::setDataChangeLogger() and HTable::clearDataChangeLogger() to set this logger in a HTable)\n\n
 *  You have to create a HTable instance which define the log sql table, and pass this HTable * to the HDataChangeLogger\n
 *  The table has to have the following fields:
 *  - HKey typed "dclkey" named (holds an autoincrement key)
 *  - HSmallText typed "pos" named (holds the program position of the change. You define it.)
 *  - HSmallText typed "cuser" named (holds the user who do the change. You define it.)
 *  - HSmallText typed "sqltablename" named (holds the changed table name. Auto.)
 *  - HSmallText typed "changedkey" named (holds the changed record's HKey. Auto.)
 *  - HSmallText typed "sqlfieldname" named (holds the chaged fields sql name. Auto.)
 *  - HSmallText typed "oldvalue" named (holds the changed fields old value. Auto.)
 *  - HSmallText typed "newvalue" named (holds the changed fields new value. Auto.)
 *  - HTimestamp typed "changetime" named (holds the changed fields mod. time. Auto.)
 *
 *  The table can contains any explain text, modifiers, comments or even more data fields.\n
 *  An example log table (HFactory XML format):
 *
 \code
 <element name="datachange_log_table">
    <table sqln="dclog">
      <key sqln="dclkey">
        <explain>Key</explain>
        <title>Key</title>
        <default>Generated</default>
        <hide/>
      </key>
      <smalltext sqln="pos">
        <explain>Position of changing</explain>
        <title>Pos</title>
      </smalltext>
      <smalltext sqln="cuser">
        <explain>Username</explain>
        <title>Username</title>
      </smalltext>
      <smalltext sqln="sqltablename">
        <explain>Sql table name which changed</explain>
        <title>Tablename</title>
      </smalltext>
      <smalltext sqln="changedkey">
        <explain>The changed records key</explain>
        <title>Changedkey</title>
      </smalltext>
      <smalltext sqln="sqlfieldname">
        <explain>Sql field name which changed</explain>
        <title>Fieldname</title>
      </smalltext>
      <smalltext sqln="oldvalue">
        <explain>The old value</explain>
        <title>OldValue</title>
      </smalltext>
      <smalltext sqln="newvalue">
        <explain>The new value</explain>
        <title>NewValue</title>
      </smalltext>
      <timestamp sqln="changetime">
        <explain>The changing time</explain>
        <title>Changetime</title>
        <default>NOW</default>
      </timestamp>
    </table>
  </element>

 \endcode
 *
 *  Here is an example function of using this code in program. I have a mytable which is generated by the HFactory.
 *  I will edit this mytable ("t" variable) and I set up the logger to work on it. (Use the example XML above)\n
 *  This function is edit (And optionally modify/log) a mytable record with "key"
 \code
 int editMytableItem(QString key)
 {
    int result=0;
    HTable *t = myfactory->genHTable("mytable"); //reads the mytable meta
    HTable *logger_table = myfactory->genHTable("datachange_log_table"); //reads the logger meta
    // You can create the table struct with logger_table->sqlCreateString() function

    //We set the logger
    HDataChangeLogger *logger = new HDataChangeLogger(logger_table,"editMytableItem","user");
    t->setDataChangeLogger(logger);
    ...
    //We create an edit dialog
    HDialog *dialog = new HDialog(this,tr("Edit my table..."),t,NULL,
                                "EscC|THoriz|Vert|StrToE|TB1Close|TB1AcceptClose|TB2Close",
                                tr("Modify the item"),tr("Modify"),tr("Cancel"),NULL);
    //Reads the current state of the record
    t->updateWithKey(key);

    //Executes the previously created dialog
    if(dialog->exec())
    {
        //If the dialog accepted, store the new values. (If some changed, the logger
        //automatically store the changes to the log table
        if(t->saveRecord() != 0)
        {
            //error occured
            result=1;
        }
    }

    delete logger;
    delete logger_table;
    delete dialog;
    delete t;
    return result;
 }
 \endcode
 *
 *  Of course you can create and set this logger object outer of this function. You can set the changed position
 *  and the user name everytime with the setPos() and setUser() functions. */
class HDataChangeLogger : public HSqlHandler
{
    Q_OBJECT

    friend class HTable;
    friend class HDataField;

public:
    /** Creates a HDataChangeLogger object.
     *  @param logtable the log table. See class details. It does not deleted on exit!
     *  @param startpos the initial position (optional)
     *  @param startuser the currently active user (optional) */
    HDataChangeLogger(HTable *logtable,QString startpos=GSAFETEXT_UNKNOWN,QString startuser=GSAFETEXT_UNKNOWN);
    /** It deletes the HDataChangeLogger. You have to delete the HTable which reference this object before
     *  or call clearDataChangeLogger() before you delete it. */
    ~HDataChangeLogger(void);

    /** Sets the currently actual modification position and user */
    void setPosAndUser(QString pos,QString user) { curr_pos = pos; curr_user = user; }
    /** Sets the currently actual modification position */
    void setPos(QString pos) { curr_pos = pos; }
    /** Sets the currently actual  user */
    void setUser(QString user) { curr_user = user; }

private:
    void setTablename(QString tablename) { curr_table = tablename; }
    void setChangedKey(QString changedkey) { curr_ckey = changedkey; }
    void addChange(QString fieldname,QString oldval,QString newval);
    void writeOut(bool tdisabled = false);

private:
    QString curr_pos;
    QString curr_user;
    QString curr_table;
    QString curr_ckey;
    HTable *logtable;
    QList<HOneDataChange> changes;
};


// ///////////////////////////////////////////////////////////////////////////////
// / Classes of HDynTable (and related) //////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////

#define HDYNELEMENT_STRING 0
#define HDYNELEMENT_DOUBLE 1

/** An element (An individual cell) of the dynamically builded HDynTable.
 *  You don't need to use this class directly use HDynTable's "defN" or "defS" methods instead this class.
 *  @see HDynTable */
class HDynTableElement
{
    friend class HDynTable;

private:
    QString name;
    QString rowName,colName;
    QString sqlname;
    QList<QString> labels;

    int type; // HDYNELEMENT_STRING:textual 1:double
    QString textual_value;
    double  double_value;

private:

    /** Creates a HDynTableElement. Use HDynTable's defN or defS methods instead.  */
    HDynTableElement(int type,QString name,QString sqlname,QString rowName,QString colName,QString labels="");

    int  getType(void);
    bool isNumeric(void);
    bool isTextual(void);

    void    setDoubleValue(double d);
    void    setTextualValue(QString s);
    double  getDoubleValue(void);
    QString getTextualValue(void);

    void addLabel(QString l);
    bool hasLabel(QString l);
};


/** The HDynTable contains the collection of numeric or textual typed fileds referenced by names.\n
 *  After you define the elements, you can easely set/get elements value referenced by it's name.
 *  The HDynTable has many batch mathematical function to easely work with the all element together.
 *  The mathematical functions only works on numeric elements, they don't affect the textual elements.
 \code
 HDynTable t;

 t.defN("a");
 t.defN("b");
 t.defS("t");


 t["a"] = 10.2;
 t["b"] = 3 * t["a"];
 t.divide(t.sum());
 t["b"] += 100;

 t["t"] = "Texual data";

 \endcode
 *
 *  The HDynTable can dynamically build a QTableWidget from the elements you defined. (See HDynTableDispConnector)\n
 *  You can define element with different column/row names, and the HDynTable will be generate the appropirate QTableWiget,
 *  It means: The same row named elements will appear in same row, if an element have unique rowname it will appear in separated row.
 *  The classes will automatically handles the refreshing the data in the memory.
 *  It means that the user changes will automatically apply on HDynTable's values.
 *  It also can handle the SQL query/update of the fileds. (See HDynTableSqlConnector)
 *
\code
    ...
    //Create an empty dyntable and define the fields
    HDynTable *dt = new HDynTable();
          //name    sqlf    rown    coln
    dt->defN("appg" ,"appg" ,"Apple","Good");
    dt->defN("appb" ,"appb" ,"Apple","Bad");
    dt->defN("pearg","pearg","Pear" ,"Good");
    dt->defN("pearb","pearb","Pear" ,"Bad");
    dt->defN("plumg","plumg","Plum" ,"Good");
    dt->defN("plumb","plumb","Plum" ,"Bad");
    dt->defN("nut"  ,"nut"  ,"Nut"  ,"Good");

    HSqlHandler *sql=new HSqlHandler();

    //Connects the dyntable to the sql table
    HDynTableSqlConnector *sql_conn = new HDynTableSqlConnector(dt,sql,"mytable");
    //Initialize the ui's table with this dyntable
    HDynTableDispConnector *disp_conn = new HDynTableDispConnector(dt,ui->table);

    //We reads the values from sql. The gui will refresh automatically.
    sql_conn->readSql();

    //We want the sql table to be updated every time, when the user change a data on gui
    connect(disp_conn,SIGNAL(dataChangedByGui()),sql_conn,SLOT(updateSql()));
    ...
 \endcode
*   The code above is generates a QTableWidget look like this:
*    \image  html pictures_doc/hdyntable.png
*   @see HDynTableDispConnector
*   @see HDynTableSqlConnector        */
class HDynTable : public HBase
{
    Q_OBJECT

private:
    QList<HDynTableElement> elements;
    QList<HDynTableElement>::iterator internal_iterator;

    /** Adds a HDynTableElement
     *  @see HDynTableElement */
    void add(HDynTableElement e);
public:
    /** Creates an empty HDynTable */
    HDynTable(void);
    /** Creates a copy of the given HDynTable */
    HDynTable(const HDynTable& t);
    ~HDynTable(void);

    /** Define a new numeric typed element (Handles double data)
     *  @param name The name to identify the field. Must be unique. You can set/get values by this name (t["name"] = 0.1;)
     *  @param sqlname The sql filed name assigned to this element
     *  @param rowName This element will be show in this named row in the dynamically builded HDynTable
     *  @param colName This element will be show in this named column in the dynamically builded HDynTable
     *  @param labels This parameters contains the "|" separated collections of text labels. You can filter many mathematical   */
    void defN(QString name,QString sqlname="",QString rowName="",QString colName="",QString labels="")
    { add(HDynTableElement(HDYNELEMENT_DOUBLE,name,sqlname,rowName,colName,labels));  }

    /** Define a new string typed element (Handles textual data)
     *  @param name The name to identify the field. Must be unique. You can set/get values by this name (t["name"] = 0.1;)
     *  @param sqlname The sql filed name assigned to this element
     *  @param rowName This element will be show in this named row in the dynamically builded HDynTable
     *  @param colName This element will be show in this named column in the dynamically builded HDynTable
     *  @param labels This parameters contains the "|" separated collections of text labels. You can filter many mathematical */
    void defS(QString name,QString sqlname="",QString rowName="",QString colName="",QString labels="")
    { add(HDynTableElement(HDYNELEMENT_STRING,name,sqlname,rowName,colName,labels));  }

    /** Define a new typed element (You can give the type in parameter)
     *  @param type The type of the field. Can be HDYNELEMENT_DOUBLE or HDYNELEMENT_STRING
     *  @param ... other parameters are same as defN,defS
     *  @see defN
     *  @see defS  */
    void defT(int type,QString name,QString sqlname="",QString rowName="",QString colName="",QString labels="")
    { add(HDynTableElement(type,name,sqlname,rowName,colName,labels));  }

    /** Clears all element from the HDynTable */
    void clear(void) { elements.clear(); }

    /** Dump out all elements name and value in one concatenated string */
    QString dumpElements(void);

    /** Sets the given named element's value */
    void setElementValue(QString name,double value);
    /** Sets the given named element's value */
    void setElementValue(QString name,QString value);

    /** Queries the given named element's double value */
    double  getElementValueDouble(QString name,bool *found=NULL);
    /** Queries the given named element's string value */
    QString getElementValueString(QString name,bool *found=NULL);

    /** Sets the specified row and column crossed element's double value */
    void setElementValueByRowColName(QString r,QString c,double value);
    /** Sets the specified row and column crossed element's string value */
    void setElementValueByRowColName(QString r,QString c,QString value);

    /** Queries the specified row and column crossed element's double value */
    double getElementValueDoubleByRowColName(QString r,QString c,bool *found=NULL);
    /** Queries the specified row and column crossed element's string value */
    QString getElementValueStringByRowColName(QString r,QString c,bool *found=NULL);

    /** Queries the given named element's sql name */
    QString getElementSqlName(QString name);


    /** Set the internal intetator to the first element.
     *  You can walk throught the elements with this functions
     \code
     HDynTable t;
     ...
     t.firstElement();
     while(!t.isEnded())
     {
        foo( t.currentElementName() + "=" + t.currentElementValueString() );

        t.nextElement();
     }
     \endcode
     *  @see isEnded()
     *  @see nextElement() */
    void firstElement(void);
    /** Check if the internal iterator reach the end of the fields.
     *  @see firstElement() */
    bool isEnded(void);
    /** Steps the internal iterator to the next element.
     *  @see firstElement() */
    void nextElement(void);

    /** Returns the name of the element in the position of internal iterator */
    QString currentElementName(void);
    /** Returns the row name of the element in the position of internal iterator */
    QString currentElementRowName(void);
    /** Returns the column name of the element in the position of internal iterator */
    QString currentElementColumnName(void);
    /** Returns the sql name of the element in the position of internal iterator */
    QString currentElementSqlName(void);
    /** Returns the labels of the element in the position of internal iterator */
    QStringList currentElementLabels(void);

    /** Returns true if the element in the position of internal iterator is numeric */
    bool    currentElementIsNumeric(void);

    /** Returns the double value of the element in the position of internal iterator */
    double  currentElementValueDouble(void);
    /** Returns the string name of the element in the position of internal iterator */
    QString currentElementValueString(void);

    /** Sets the value of the element in the position of internal iterator */
    void setCurrentElementValue(double d);
    /** Sets the value of the element in the position of internal iterator */
    void setCurrentElementValue(QString s);


    /** Sets all elements value to zero and empty string.
     *  @param limitTo if you give this parameter only the given labelled element's are zeroed */
    void   emptyall(QString limitTo = "");
    /** Sets all element's value to zero.
     *  @param limitTo if you give this parameter only the given labelled element's are zeroed */
    void   zeroall(QString limitTo = "");
    /** Returns the maximum valued element.
     *  @param limitTo if you give this parameter only the given labelled element's are examined */
    double max(QString limitTo = "");
    /** Returns the minimum valued element.
     *  @param limitTo if you give this parameter only the given labelled element's are examined */
    double min(QString limitTo = "");
    /** Returns the sum of element's value.
     *  @param limitTo if you give this parameter only the given labelled element's are examined */
    double sum(QString limitTo = "");

    /** Substract a double value from all double cell */
    void sustraction(double d,QString limitTo = "");
    /** Field to field substraction of the tables (The two tables field's must be same) */
    void sustraction(HDynTable dt,QString limitTo = "");
    /** Add a double value to all double cell */
    void addition(double d,QString limitTo = "");
    /** Field to field addition of the tables (The two tables field's must be same) */
    void addition(HDynTable dt,QString limitTo = "");
    /** Multiplicate all double cell with a double value  */
    void multiplicate(double d,QString limitTo = "");
    /** Field to field multiplication of the tables (The two tables field's must be same) */
    void multiplicate(HDynTable dt,QString limitTo = "");
    /** Divide all double cell with a double value  */
    void divide(double d,QString limitTo = "");
    /** Field to field divide of the tables (The two tables field's must be same) */
    void divide(HDynTable dt,QString limitTo = "");

    /** Returns the number of all defined elements(with no argument) or a specified labelled elements. (if nonempty argument passed) */
    int countElements(QString limitTo="");

    /** Returns the first element's index matching the name passed in parameter. Returns -1 if the element did not found. */
    int indexByElementName(QString name);
    /** Returns the first element's index matching the sqlname passed in parameter. Returns -1 if the element did not found. */
    int indexByElementSqlName(QString sqlname);
    /** Returns the name of the index'th element */
    QString indexedElementName(int index);
    /** Returns the sql name of the index'th element */
    QString indexedElementSqlName(int index);
    /** Returns the row name of the index'th element */
    QString indexedElementRowName(int index);
    /** Returns the column name of the index'th element */
    QString indexedElementColName(int index);
    /** Returns the value name of the index'th element
     *  @param If you give this bool pointer the pointer will be set to true any cases the element has been found */
    double getIndexedValueDouble(int index,bool *found=NULL);
    /** Returns the value name of the index'th element
     *  @param If you give this bool pointer the pointer will be set to true any cases the element has been found */
    QString getIndexedValueString(int index,bool *found=NULL);

    /** Sets the index'th elements value */
    void setIndexedElementValue(int index,double d);
    /** Sets the index'th elements value */
    void setIndexedElementValue(int index,QString s);

    /** Returns true if the given named element has a given label. Otherwise returns false.
     *  @param name The examided element's name
     *  @param label The label name to check
     *  @param If you give this bool pointer the pointer will be set to true any cases the element has been found */
    bool elementHasLabel(QString name,QString label,bool *found=NULL);

private:
    HDynTableElement& getElementByName(QString name);

    class HDynTableElementNameReferencer
    {
        private:
            HDynTable* ref;
            QString name;

            friend class HDynTable;
            HDynTableElementNameReferencer(HDynTable *ref,QString name)
            {   this->ref = ref;	this->name = name;   }
        public:
            HDynTableElementNameReferencer operator=(double value)
                    { ref->setElementValue(name,value); return *this; }
            HDynTableElementNameReferencer operator=(QString value)
                    { ref->setElementValue(name,value); return *this; }
            operator double()
                    { return ref->getElementValueDouble(name); }
            operator QString()
                    { return ref->getElementValueString(name); }

            HDynTableElementNameReferencer operator+=(double value)
                    { ref->setElementValue(name,ref->getElementValueDouble(name)+value); return *this; }
            HDynTableElementNameReferencer operator-=(double value)
                    { ref->setElementValue(name,ref->getElementValueDouble(name)-value); return *this; }
            HDynTableElementNameReferencer operator*=(double value)
                    { ref->setElementValue(name,ref->getElementValueDouble(name)*value); return *this; }
            HDynTableElementNameReferencer operator/=(double value)
                    { ref->setElementValue(name,ref->getElementValueDouble(name)/value); return *this; }
    };

public:

    /** You can set/get element's value by name with this operator */
    HDynTableElementNameReferencer operator[](QString name) { return HDynTableElementNameReferencer(this,name); }

    HDynTable& operator=(HDynTable s);

signals:
    /** Emitted when the data changed in the memory.
     *  It does not emits when the element's structure changed (added/cleared) */
    void dataChangedNongui(void);

};

/** This class can connect a HDynTable object to the sql database.
  * It can read/update/insert the data according the emelent's sqlname attribute and the given parameters.
  * (You can see an example in HDynTable describe)
  * @see HDynTable */
class HDynTableSqlConnector : public HSqlHandler
{
    Q_OBJECT

public:
    /** If this attribute is true, the class doesn't start a new transaction when run an sql query
     *  Default is false. */
    bool tdisabled;
    /** This text is passed to the HSqlHandler when a new sql query started.
     *  Default is "Error in HDynTableSqlConnector" */
    QString errorText;

    /** It creates a connection to the database
      * @param dynt The HDynTable to connect.
      * @param tablename The name of the sql table contains the data
      * @param filterpart Can contains a SQL filter text which used on reading/updating.
      *         It can be empty, or "key='1' for exmaple." */
    HDynTableSqlConnector(HDynTable *dynt,QString tablename,QString filterpart="")
    {
        this->dynt       = dynt;
        this->tablename  = tablename;
        this->filterpart = filterpart;
        errorText =  "Error in HDynTableSqlConnector";
        tdisabled = false;
    }

    ~HDynTableSqlConnector(void)
    {
        this->dynt       = NULL;
        this->tablename  = "";
        this->filterpart = "";
    }

    /** Inserts the content of table to the database according the parameters given to the constructor
     *  @param additionaldefpart Additional fields to insert, definitions (Example: "id,lastmod")
     *  @param additionalvaluepart Additional filelds to insert, values (Example: "\'001\',now()") */
    void insertSql(QString additionaldefpart="",QString additionalvaluepart="");

    /** Generates the sql create (DDL) string of the meta table. (CREATE TABLE ...)
     *  @return The sql create command
     *  @param switches string can contain modifiers. Currently there is not implemented any modifier. */
    QString sqlCreateString(QString switches="");

public slots:
    /** Reads the data from sql */
    int readSql(void);
    /** Updates the data to the sql */
    int updateSql(void);
signals:
    /** Emitted when the data just readed from the sql database */
    void justReaded(void);
    /** Emitted when the data just updated to the sql database */
    void justUpdated(void);

private:
    HDynTable *dynt;
    QString tablename;
    QString filterpart;

};

/* @} */
#endif

//End of gSAFE datalib.h
